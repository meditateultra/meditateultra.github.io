<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【论文阅读】Towards Impartial Multi-Task Learning</title>
      <link href="/2022/08/16/ml/lun-wen-yue-du-towards-impartial-multi-task-learning/"/>
      <url>/2022/08/16/ml/lun-wen-yue-du-towards-impartial-multi-task-learning/</url>
      
        <content type="html"><![CDATA[<p>文章主要提出了一种方法能够均衡的学习multi task learning问题，这种方法的优点是不需要对分布有任何假设，并且对gradient scale的过程是和训练过程同步的，同时文章发现对loss balance和gradients balance是互补的，因此提出了一种混合的方法能够更好平衡gradients和losses。</p><p>这篇文章的推导过程还是比较精妙的，我只看懂了70%。</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>MTL的问题中平衡方法分为loss balance和gradients balance两种，这篇文章综合了这两种方法。</p><p>详细解读过程可以看论文阅读的PDF。</p><p><img src="http://img.meditate.eu.org/note/image-20220816171337469.png" alt="IMTL的算法过程"></p><p>gradients balance在文章中提出的方法是IMTL-G，用来更新共享层的参数。</p><p>loss balance提出的方法是IMTL-L，通过认为构造scaled loss函数来达到目的。</p><p>文章中提出的scaled loss如下所示：<br>$$<br>g\left( s \right) =e^sL\left( \theta \right) -s<br>$$<br>这个函数是关于s和$\theta$的函数，s是缩放系数，$\theta$是各个任务单独的权重，这样就可以在模型中分别求偏导来更新两个变量。</p><p>$L\left( \theta \right) $是原始损失，$e^s$是为了将s映射到正实数。-s是正则化项，为了避免s找到负无穷的平凡解。</p><p>构造scaled loss的原因和过程可以看论文PDF。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Task Switching Network for Multi-task Learning</title>
      <link href="/2022/08/16/ml/lun-wen-yue-du-task-switching-network-for-multi-task-learning/"/>
      <url>/2022/08/16/ml/lun-wen-yue-du-task-switching-network-for-multi-task-learning/</url>
      
        <content type="html"><![CDATA[<p>这篇论文提出了任务交换网络（TSN），首次使用单编码器-单解码器的结构显著减少了参数量。</p><h1 id="TSN"><a href="#TSN" class="headerlink" title="TSN"></a>TSN</h1><p><img src="http://img.meditate.eu.org/note/image-20220808230903682.png" alt="TSN的总体结构"></p><p>主干网络是Resnet-18，解码器中每一层会接受上一层中上采样后的特征图拼接上本层的特征图。</p><p>与以往的模型最大的区别在于输出后面只接了一个头（decoder）。做卷积之后利用这一个头去完成不同的任务。为了区分不同的任务，引入了Task Embedding，为每个任务得到一个$l_{\tau}$向量通过某种方式区分不同的任务。输出通道数的选择也是有讲究的，一般<strong>取所有任务中所需输出的最大的通道数</strong>。这样对于其他的任务，可以沿通道执行平均池化来适应不同的任务。（多说一句，平均池化是没有参数的，所以不会增加额外的参数）</p><h2 id="Task-Embedding-Network"><a href="#Task-Embedding-Network" class="headerlink" title="Task Embedding Network"></a>Task Embedding Network</h2><p>这是一个得到$l_{\tau}$向量的过程。如图中的左下角</p><p>首先，要为每个任务初始化一个d维的条件向量。根据执行的任务的不同，选择任务对应的向量$v_{\tau}$。然后经过一个全连接层，输出一个$l_{\tau}$，仍然为d维。<br>$v_{\tau}$的选择有两种：</p><ol><li>不同的任务的条件向量是正交</li></ol><p>$$<br>v_{\tau ^1}^Tv_{\tau ^2}=\begin{cases}<br>    \frac{d}{T},&amp;        \tau _1=\tau _2\<br>    0,&amp;        otherwise\<br>\end{cases}<br>$$</p><ol start="2"><li>$v_{\tau}$是高斯随机矩阵</li></ol><p>$$<br>v_{\tau}\sim N\left( 0_d,\text{diag}\left( 1_d \right) \right)<br>$$</p><h2 id="Conditional-Convolution-Module"><a href="#Conditional-Convolution-Module" class="headerlink" title="Conditional Convolution Module"></a>Conditional Convolution Module</h2><p>也就是A模块，其结构如图中右下角所示</p><p>输入的张量的通道数为c</p><p>上一步中得到的$l_{\tau}$会经过两个全连接层，将d维的向量映射到c维去。这样会分别得到两个向量$\gamma$和$\beta$。</p><p>随后经过AdaIN函数，其中的$\mu$代表均值，$\sigma ^2$代表方差。</p><p>这两个值是通过Instance Normalization（IN）得到的。具体可见：<a href="https://blog.csdn.net/u011447962/article/details/117714531?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-117714531-blog-125660719.pc_relevant_show_downloadRating&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-117714531-blog-125660719.pc_relevant_show_downloadRating&amp;utm_relevant_index=2">https://blog.csdn.net/u011447962/article/details/117714531?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-117714531-blog-125660719.pc_relevant_show_downloadRating&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-117714531-blog-125660719.pc_relevant_show_downloadRating&amp;utm_relevant_index=2</a></p><p>简单来说就是对于每个通道内部求均值方差。<br>$$<br>AdaIN\left( \hat{x},\beta ,\gamma \right) =\gamma \frac{\left( \hat{x}-\mu \right)}{\sqrt{\sigma ^2}}+\beta<br>$$<br>所以这个式子就是做IN的过程。$\gamma$和$\beta$称为缩放系数和偏移量。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Multi-task Learning with Attention for End-to-end Autonomous Driving</title>
      <link href="/2022/08/16/ml/lun-wen-yue-du-multi-task-learning-with-attention-for-end-to-end-autonomous-driving/"/>
      <url>/2022/08/16/ml/lun-wen-yue-du-multi-task-learning-with-attention-for-end-to-end-autonomous-driving/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是自动驾驶领域的文章，自动驾驶领域往往有两类任务：<strong>感知环境</strong>（如：语义分割），<strong>驾驶决策</strong>（根据周围环境做出相应的操作）。</p><p>这篇文章聚焦于自动驾驶中的点对点的导航问题，将多任务学习引入了自动驾驶，并且引入了注意力机制有效提高了准确率，文末也通过可视化图热图对注意力机制进行了定性的分析。本文的模型能够识别红绿灯（以往的模型做不到）。</p><p><strong>这篇文章是基于RGB单目相机，并且是端到端的，采用了CIL框架</strong>。（端到端指的是输入是原始数据，输出是最后的结果，原来输入端不是直接的原始数据，而是在原始数据中提取的特征）</p><p>个人认为这篇文章最大的创新点就是利用注意力机制在一个encoder上得到了两个type（对应与上面提到的自动驾驶的两类任务），然后在两个type后面接不同的解码器做不同的任务。</p><h1 id="CBAM"><a href="#CBAM" class="headerlink" title="CBAM"></a>CBAM</h1><p>文章中用到了CBAM模块，首先对它进行一个介绍。</p><p><strong>卷积块注意模块（CBAM）</strong>融合了通道注意力机制和空间注意力机制。采用模块化的设计，几乎可以没有开销地嵌入任何网络。</p><p>总体的结构如下图，它首先做通道注意力，再做空间注意力</p><p><img src="http://img.meditate.eu.org/note/image-20220810100551027.png" alt="卷积块注意模块（CBAM）"></p><h2 id="通道注意力模块"><a href="#通道注意力模块" class="headerlink" title="通道注意力模块"></a>通道注意力模块</h2><p><img src="http://img.meditate.eu.org/note/image-20220810100817512.png" alt="通道注意力模块"></p><ol><li>首先在每个通道上做最大池化和平均池化</li><li>分别将两个向量输入一个全连接的网络，输出要与输入向量的长度保持一致</li><li>将两个向量相加，经过Sigmoid函数。得到的向量表示每个通道对应的权重。</li><li>将向量与输入的特征图的每个对应的通道相乘</li></ol><h2 id="空间注意力模块"><a href="#空间注意力模块" class="headerlink" title="空间注意力模块"></a>空间注意力模块</h2><p><img src="http://img.meditate.eu.org/note/image-20220810101815278.png" alt="空间注意力模块"></p><ol><li>沿着通道做最大池化和平均池化。以最大池化为例：就是在所有通道的对应像素点中取一个最大值。得到两个二维的特征图。</li><li>将两个特征图沿着通道拼起来，通过一个卷积层，文章中是7*7的卷积，得到一个<strong>二维</strong>的特征图。</li><li>经过Sigmoid函数，得到的是特征图中每个像素点对应的权重。</li><li>将权重图与输入图中对应位置相乘。</li></ol><h2 id="ResNet引入CBAM"><a href="#ResNet引入CBAM" class="headerlink" title="ResNet引入CBAM"></a>ResNet引入CBAM</h2><ul><li>CBAM并不会影响原来的网络结构</li><li>CBAM加在残差连接之前</li></ul><p><img src="http://img.meditate.eu.org/note/image-20220810102431347.png" alt="Resnet中加入CBAM"></p><h1 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h1><p><img src="http://img.meditate.eu.org/note/image-20220810103009942.png" alt="模型结构"></p><h2 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h2><p><img src="http://img.meditate.eu.org/note/image-20220810123214170.png" alt="Encoder的结构"></p><p>主干网络采用了ResNet-34，引申出了两种type。type1后续会接上decoder用于处理语义分割，深度预测的任务。type2会去处理信号灯分类和控制预测。作者也对这种操作做了简单的说明，因为语义分割和深度预测往往需要更高分辨率的特征图以免丢失细节，而信号灯分类和控制预测需要隐藏抽象特征。</p><p>注意这里的Conv Block，经过池化以后通道数是不变的，为了能与下一层的特征图相加，接上了一个卷积来使通道数翻倍。</p><h2 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h2><p>这一部分文章写得有点坑，图中两个decoder的结构参考了一篇论文，然而那篇论文又参考了另一篇论文o(╥﹏╥)o。然而，我读了两篇论文后，发现这里的结构不可能完全与它们一致。所以实际结构怎么样只有看了源码才知道。不过这并不影响理解这部分。</p><p>实际上简单思考也知道，由于==decoder的输出和网络的输入图像是一样大小的==。因此，这里的decoder肯定是用了几个上采样调整到与原图一样的尺寸，最后接上一个softmax。</p><p>作者也说了，经过实验发现，当segmentation的decoder深度大于depth的decoder深度时，模型的整体效果比较好。</p><h2 id="信号灯分类"><a href="#信号灯分类" class="headerlink" title="信号灯分类"></a>信号灯分类</h2><p>分为四类：红，黄，绿，无信号灯。对采集到的每一帧都给出一个分类</p><p>应该就是连个全连接层。</p><h2 id="驾驶模块"><a href="#驾驶模块" class="headerlink" title="驾驶模块"></a>驾驶模块</h2><p>这里会有两个额外的输入信息，分别是车辆的速度v和更高级别的命令c（如左转）。type2 的特征图展开成一个向量。</p><p>驾驶模块中接了四个不同的头，分别对应于4中不同的高级命令（车道保持，左转，右转，直行）。根据输入的高级命令c，选择不同的头输出操作指令。这种多头的结构要好于单头（之前的论文证明过）。</p><p>==说明：==车辆在面对十字路口中，往往可以有多个指令的选择，这会引起歧义。CIL框架为了解决这个问题会给出一个高级命令（如左转）。然后模型根据这个命令给出更加基础的操作（踩油门，踩刹车，转方向盘）。这个高级指令在这篇文章中是使用A*算法做路径规划给出的。它对没一帧的画面都会给出一个c指示下一步前进的方向。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>$$<br>L_{total}=\lambda <em>{control}L</em>{control}+\lambda <em>{tl}L</em>{tl}+\lambda <em>{seg}L</em>{seg}+\lambda <em>{dep}L</em>{dep}<br>$$</p><p>$$<br>L_{control}=\sum_{c=1}^3{\gamma _cL_c}<br>$$</p><p>$L_{control}$和$L_{dep}$采用均方差损失，$L_{tl}$和$L_{seg}$采用交叉熵损失。</p><p>第二个式子中c=1代表转向，c=2代表油门，c=3代表刹车</p><p>$\lambda$和$\gamma$凭经验设置。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="数据集增强和数据集均衡"><a href="#数据集增强和数据集均衡" class="headerlink" title="数据集增强和数据集均衡"></a>数据集增强和数据集均衡</h2><p>为了扩充数据集，作者做了数据集增强。</p><p>采集到的数据集是不平衡的（直线行驶特别多），于是文章采用降采样的方法，让直线行驶选中的概率降低。实测下来数据集均衡对于模型非常重要。</p><p>实验结果看看table就明白了。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2022/06/24/develop/docker/"/>
      <url>/2022/06/24/develop/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p>英文文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a></p><p>docker中文文档：<a href="https://gitee.com/docker_practice/docker_practice#https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fyeasy%2Fdocker_practice">https://gitee.com/docker_practice/docker_practice#https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fyeasy%2Fdocker_practice</a></p><h2 id="一-docker的定义"><a href="#一-docker的定义" class="headerlink" title="一 docker的定义"></a>一 docker的定义</h2><p>docker就是一种容器应用，用于更好地发布应用。docker可以直接装一个个的软件服务。当我们需要安装redis，MySQL时我们需要下载很多的环境，这会非常的繁琐。并且，当我们想将软件给其他人时，往往会出现“这段代码在我的机器上没问题啊”的问题。docker就很好地解决了这个问题，他将你的应用和你的环境做一个打包，就像一个个的集装箱一样，将各个应用进行隔离，这样就可以<strong>运行你的应用而不需要安装环境</strong>了。</p><p>当我们把应用和容器打包到一起时，我们称之为<strong>镜像</strong>。</p><p><strong>更高效的利用系统资源</strong></p><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，<code>Docker</code> 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><p><strong>更快速的启动时间</strong></p><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code> 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><p><strong>一致的运行环境</strong></p><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p><p><strong>持续交付和部署</strong></p><p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps">DevOps (opens new window)</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p><p>使用 <code>Docker</code> 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a href="https://vuepress.mirror.docker-practice.com/image/dockerfile/">Dockerfile</a> 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(Continuous Integration) (opens new window)</a>系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery">持续部署(Continuous Delivery/Deployment) (opens new window)</a>系统进行自动部署。</p><p>而且使用 <a href="https://vuepress.mirror.docker-practice.com/image/build.html"><code>Dockerfile</code></a> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><p><strong>更轻松的迁移</strong></p><p>由于 <code>Docker</code> 确保了执行环境的一致性，使得应用的迁移更加容易。<code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><p><strong>更轻松的维护和扩展</strong></p><p><code>Docker</code> 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&image_filter=official">官方镜像 (opens new window)</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本</p><p><strong>对比传统虚拟机</strong></p><table><thead><tr><th align="left">特性</th><th align="left">容器</th><th align="left">虚拟机</th></tr></thead><tbody><tr><td align="left">启动</td><td align="left">秒级</td><td align="left">分钟级</td></tr><tr><td align="left">硬盘使用</td><td align="left">一般为 <code>MB</code></td><td align="left">一般为 <code>GB</code></td></tr><tr><td align="left">性能</td><td align="left">接近原生</td><td align="left">弱于</td></tr><tr><td align="left">系统支持量</td><td align="left">单机支持上千个容器</td><td align="left">一般几十个</td></tr></tbody></table><h2 id="二-docker安装"><a href="#二-docker安装" class="headerlink" title="二 docker安装"></a>二 docker安装</h2><p><a href="https://docs.docker.com/engine/install/centos/#install-using-the-convenience-script">https://docs.docker.com/engine/install/centos/#install-using-the-convenience-script</a></p><p>只有centos7+才能安装docker</p><p>docker安装方式有很多，推荐使用脚本安装。可以在任意Linux系统上安装</p><p>首先下载docker安装的脚本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> -fsSL get.docker.com -o get-docker.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过下载的脚本来下载docker引擎，推荐使用阿里云镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sh</span> get-docker.sh --mirror Aliyun<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动docker服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span> <span class="token comment">#将docker加入开机自启动的列表</span>systemctl start <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>推荐将当前用户加入docker组</p><p>创建docker组</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">groupadd</span> <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将当前用户加入docker组</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">usermod</span> -aG <span class="token function">docker</span> <span class="token environment constant">$USER</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试docker安装是否正确</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> version<span class="token function">docker</span> info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="三-docker的核心概念"><a href="#三-docker的核心概念" class="headerlink" title="三 docker的核心概念"></a>三 docker的核心概念</h2><p><strong>镜像 Image</strong></p><p>一个镜像就代表一个软件。</p><p><strong>容器 Container</strong></p><p>一个镜像运行一次就会生成一个容器。容器就是一个运行的软件服务。</p><p>举例：我可以在一台电脑中开多个Chrome浏览器。</p><p><strong>仓库 docker repository</strong></p><p>docker在全球范围内维护了一个镜像仓库。类似于maven</p><p><strong>远程仓库：docker hub</strong></p><p><a href="https://registry.hub.docker.com/_/tomcat?tab=tags">https://registry.hub.docker.com/_/tomcat?tab=tags</a></p><p><strong>本地仓库</strong>：用来存储在使用docker过程中的相关镜像</p><h2 id="四-配置阿里云镜像加速"><a href="#四-配置阿里云镜像加速" class="headerlink" title="四 配置阿里云镜像加速"></a>四 配置阿里云镜像加速</h2><p>阿里云会为每个开发者分配一个单独的镜像</p><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> -p /etc/docker<span class="token function">sudo</span> <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'&#123;  "registry-mirrors": ["自己的url"]&#125;EOF</span><span class="token function">sudo</span> systemctl daemon-reload<span class="token function">sudo</span> systemctl restart <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五-镜像操作"><a href="#五-镜像操作" class="headerlink" title="五 镜像操作"></a>五 镜像操作</h2><h3 id="1-查看本地仓库有那些镜像"><a href="#1-查看本地仓库有那些镜像" class="headerlink" title="1 查看本地仓库有那些镜像"></a>1 查看本地仓库有那些镜像</h3><p><img src="http://img.meditate.eu.org/note/image-20211226161858115.png" alt="image-20211226161858115"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看本地仓库有那些镜像</span><span class="token function">docker</span> imgae <span class="token function">ls</span>或者<span class="token function">docker</span> images<span class="token comment">#查看指定镜像名</span><span class="token function">docker</span> images 镜像名<span class="token comment">#只列出镜像id</span><span class="token function">docker</span> images -q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>docker可以通过id和名称:版本来查找镜像</p><h3 id="2-下载镜像"><a href="#2-下载镜像" class="headerlink" title="2 下载镜像"></a>2 下载镜像</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull name:tag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-搜索镜像"><a href="#3-搜索镜像" class="headerlink" title="3 搜索镜像"></a>3 搜索镜像</h3><p>查看镜像是否存在，不能查看版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> search name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-删除镜像"><a href="#4-删除镜像" class="headerlink" title="4 删除镜像"></a>4 删除镜像</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#正常删除。只能删除没有运行过的镜像</span><span class="token function">docker</span> image <span class="token function">rm</span> 镜像名（name:tag）<span class="token operator">|</span>镜像id<span class="token comment">#强制删除。镜像和容器一起删除</span><span class="token function">docker</span> image <span class="token function">rm</span> -f 镜像名（name:tag）<span class="token operator">|</span>镜像id<span class="token comment">#举例：删除所有Tomcat的镜像</span><span class="token function">docker</span> image <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> images tomcat -q<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-镜像备份和恢复"><a href="#5-镜像备份和恢复" class="headerlink" title="5 镜像备份和恢复"></a>5 镜像备份和恢复</h3><p>可以将docker打包成一个tar包，方便传输和储存。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#打包镜像</span><span class="token function">docker</span> save 镜像名：版本 -o <span class="token punctuation">(</span>镜像名-版本号<span class="token punctuation">)</span>.tar<span class="token comment">#恢复镜像</span><span class="token function">docker</span> load -i <span class="token punctuation">(</span>tar包的名字<span class="token punctuation">)</span>.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-查看镜像的构建历史"><a href="#6-查看镜像的构建历史" class="headerlink" title="6 查看镜像的构建历史"></a>6 查看镜像的构建历史</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">history</span> 镜像名：版本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="六-容器的操作"><a href="#六-容器的操作" class="headerlink" title="六 容器的操作"></a>六 容器的操作</h2><h3 id="1-查看正在运行的容器"><a href="#1-查看正在运行的容器" class="headerlink" title="1 查看正在运行的容器"></a>1 查看正在运行的容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">ps</span><span class="token comment">#查看所有容器，包括停止的</span><span class="token function">docker</span> <span class="token function">ps</span> -a<span class="token comment">#查看所有容器的id</span><span class="token function">docker</span> <span class="token function">ps</span> -aq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-运行一个容器"><a href="#2-运行一个容器" class="headerlink" title="2 运行一个容器"></a>2 运行一个容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run name:tag或者<span class="token function">docker</span> run imageid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>container id(容器id)</p><p>imgae(基于哪个镜像)</p><p>command（容器内启动服务的命令）</p><p>names（容器的名称，可以自己指定，不指定则由docker自动分配）</p><p><img src="http://img.meditate.eu.org/note/image-20211226164719464.png" alt="image-20211226164719464"></p><h3 id="3-容器映射"><a href="#3-容器映射" class="headerlink" title="3 容器映射"></a>3 容器映射</h3><p>由于docker是操作系统层面的隔离，所以容器有自己的端口。为了在外部访问到容器，要将容器的端口与外部主机的端口相映射。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">8080</span>（宿主机）:8080 tomcat:8.0 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-p可以写多个映射</p><h3 id="4-后台启动"><a href="#4-后台启动" class="headerlink" title="4 后台启动"></a>4 后台启动</h3><p>以守护进程的方式启动。否则每启动一个容器就要重新打开一个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">8080</span>（宿主机）:8080 -d tomcat:8.0 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-给容器取名"><a href="#5-给容器取名" class="headerlink" title="5 给容器取名"></a>5 给容器取名</h3><p>这个name必须是唯一的</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">8080</span>（宿主机）:8080 -d --name tomcat01 tomcat:8.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-停止-重启-启动-暂停-恢复容器"><a href="#6-停止-重启-启动-暂停-恢复容器" class="headerlink" title="6 停止 重启 启动 暂停 恢复容器"></a>6 停止 重启 启动 暂停 恢复容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#停止</span><span class="token function">docker</span> stop 容器名称<span class="token operator">|</span>容器id<span class="token comment">#重启</span><span class="token function">docker</span> restart 容器名称<span class="token operator">|</span>容器id<span class="token comment">#启动</span><span class="token function">docker</span> start 容器名称<span class="token operator">|</span>容器id<span class="token comment">#暂停</span><span class="token function">docker</span> pause 容器名称<span class="token operator">|</span>容器id<span class="token comment">#恢复</span><span class="token function">docker</span> unpause 容器名称<span class="token operator">|</span>容器id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-杀死容器"><a href="#7-杀死容器" class="headerlink" title="7 杀死容器"></a>7 杀死容器</h3><p>与stop不同，kill容器容器中不会进行后续操作，属于强制停止。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">kill</span> 容器名称<span class="token operator">|</span>容器id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="8-删除容器"><a href="#8-删除容器" class="headerlink" title="8 删除容器"></a>8 删除容器</h3><p>删除容器不会影响到镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#不在运行的容器</span><span class="token function">docker</span> <span class="token function">rm</span> 容器名称<span class="token operator">|</span>容器id<span class="token comment">#强制删除容器</span><span class="token function">docker</span> <span class="token function">rm</span> -f 容器名称<span class="token operator">|</span>容器id<span class="token comment">#删除所有容器</span><span class="token function">docker</span> <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> -aq<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-查看容器日志"><a href="#9-查看容器日志" class="headerlink" title="9 查看容器日志"></a>9 查看容器日志</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> logs 容器名称<span class="token operator">|</span>容器id<span class="token comment">#查看实时的日志</span><span class="token function">docker</span> logs -f 容器名称<span class="token operator">|</span>容器id<span class="token comment">#加上宿主机中的时间</span><span class="token function">docker</span> logs -t 容器名称<span class="token operator">|</span>容器id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-进入容器的内部"><a href="#10-进入容器的内部" class="headerlink" title="10 进入容器的内部"></a>10 进入容器的内部</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it 容器名称<span class="token operator">|</span>容器id <span class="token function">bash</span><span class="token comment">#-it 代表以交互模式进入</span><span class="token comment">#与容器中的bash交互</span><span class="token comment">#退出容器</span><span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-容器与宿主机之间的文件传输"><a href="#11-容器与宿主机之间的文件传输" class="headerlink" title="11 容器与宿主机之间的文件传输"></a>11 容器与宿主机之间的文件传输</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#将容器中的文件或目录拷贝到宿主机</span><span class="token function">docker</span> <span class="token function">cp</span> 容器名称<span class="token operator">|</span>容器id:文件或目录 宿主机中的目录<span class="token comment">#将宿主机上的文件或目录拷贝到容器中</span><span class="token function">docker</span> <span class="token function">cp</span> 宿主机中的目录或文件 容器名称<span class="token operator">|</span>容器id:容器的目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-查看容器内运行的进程"><a href="#12-查看容器内运行的进程" class="headerlink" title="12 查看容器内运行的进程"></a>12 查看容器内运行的进程</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">top</span> 容器名称<span class="token operator">|</span>容器id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13-查看容器内细节指令"><a href="#13-查看容器内细节指令" class="headerlink" title="13 查看容器内细节指令"></a>13 查看容器内细节指令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> inspect 容器名称<span class="token operator">|</span>容器id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="14-容器的数据卷机制"><a href="#14-容器的数据卷机制" class="headerlink" title="14 容器的数据卷机制"></a>14 容器的数据卷机制</h3><p>data volume：用来实现容器中数据和宿主机中的数据进行映射。通俗来说就是设置一块空间与容器中的目录和宿主机中的目录进行映射。这样容器空间与宿主机的目录就实现了双向绑定。随便更改哪边另一边都会更改。</p><h4 id="14-1-数据卷挂载"><a href="#14-1-数据卷挂载" class="headerlink" title="14.1 数据卷挂载"></a>14.1 数据卷挂载</h4><p><strong>数据卷只能在容器首次启动时设置</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#使用绝对路径设置数据卷（可以多个）</span><span class="token function">docker</span> run -v 宿主机绝对路径:容器内路径<span class="token comment">#注意：这种方式启动时会将容器路径的内容全部清空</span><span class="token function">docker</span> run -v 宿主机绝对路径:容器内路径:ro<span class="token comment">#设置ro时表示容器内的目录是只读的。只能通过宿主机操作。</span><span class="token comment">#使用别名方式设置数据卷</span><span class="token function">docker</span> run -v 别名:容器内路径<span class="token comment">#例如</span><span class="token function">docker</span> run -v aa:/usr/local/tomcat/webapps<span class="token comment">#aa代表docker数据卷中的别名，aa不存在会自动创建，存在则直接使用</span><span class="token comment">#使用别名方式会保留容器路径原始内容，前提是别名对应的路径不存在内容</span><span class="token comment"># 别名挂载还有一种匿名挂载</span><span class="token function">docker</span> run -d  -v 容器内目录  镜像名/id  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>docker根据别名创建的目录一般在/var/lib/docker/volume</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看所有挂载的卷</span><span class="token function">docker</span> volume <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="14-2-数据卷容器"><a href="#14-2-数据卷容器" class="headerlink" title="14.2 数据卷容器"></a>14.2 数据卷容器</h4><p>一个容器可以通过<code>volumes from</code>直接使用其他容器的数据卷挂载方式。并且这样指定后，多个容器是共享数据卷的，共享的数据卷只要还有容器使用它就不会消失。可以通过这种 机制来实现配合文件的共享或者数据库的数据同步等操作。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it --name container02 --volumes from container01 镜像名/id  <span class="token comment"># 将两个容器进行挂载</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="15-将容器打包成一个镜像"><a href="#15-将容器打包成一个镜像" class="headerlink" title="15 将容器打包成一个镜像"></a>15 将容器打包成一个镜像</h3><p>将自己的容器打包成一个镜像，这样以后只需要运行相应的镜像就行了</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> commit -m <span class="token string">"描述信息"</span> -a <span class="token string">"作者"</span> 容器名称<span class="token operator">|</span>容器id 镜像名：版本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="16-查看容器或者镜像的信息"><a href="#16-查看容器或者镜像的信息" class="headerlink" title="16 查看容器或者镜像的信息"></a>16 查看容器或者镜像的信息</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> inspect 镜像<span class="token operator">|</span>容器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="七-镜像构成原理"><a href="#七-镜像构成原理" class="headerlink" title="七 镜像构成原理"></a>七 镜像构成原理</h2><p><strong>自己打包的镜像为什么那么大？</strong></p><p>因为容器是一种轻量级的，可执行的独立软件包，它包含了软件运行的库。</p><p><strong>为什么从官方下载的镜像那么小？</strong></p><p>因为docker使用了联合文件系统。每个镜像存在一个base镜像，这样就实现了底层镜像的复用，不用存储每个重复的运行依赖。因此，当我们下载Tomcat8.0时，会发现我们要下载许多东西，当我们下载Tomcat8.1时会发现下载的东西变少了。</p><p>每个镜像都由很多层次构成，Docker 使用 <a href="https://en.wikipedia.org/wiki/UnionFS">Union FS (opens new window)</a>将这些不同的层结合到一个镜像中去。</p><p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。</p><p>Docker 在 OverlayFS 上构建的容器也是利用了类似的原理。</p><h2 id="八-dockerFile"><a href="#八-dockerFile" class="headerlink" title="八 dockerFile"></a>八 dockerFile</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h3><p>dockerfile是用来构建docker镜像的文件，是一个<strong>命令参数脚本</strong>。</p><p>官方镜像的很多都是基础包，我们通常会构建自己的镜像。</p><p>构建步骤：</p><ol><li>编写一个dockerfile文件</li><li>docker build为一个镜像</li><li>docker run运行镜像</li><li>docker push发布镜像</li></ol><h3 id="2-指令"><a href="#2-指令" class="headerlink" title="2 指令"></a>2 指令</h3><table><thead><tr><th align="center">命令</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">FROM</td><td align="center">基础镜像：Centos/Ubuntu</td></tr><tr><td align="center">MAINTAINER</td><td align="center">镜像作者+邮箱</td></tr><tr><td align="center">RUN</td><td align="center">镜像构建的时候需要运行的命令</td></tr><tr><td align="center">ADD</td><td align="center">为镜像添加内容（压缩包）</td></tr><tr><td align="center">WORKDIR</td><td align="center">镜像工作目录（进入容器时的目录）</td></tr><tr><td align="center">VOLUME</td><td align="center">挂载的目录</td></tr><tr><td align="center">EXPOSE</td><td align="center">暴露端口配置</td></tr><tr><td align="center">CMD/ENTRYPOINT</td><td align="center">指定这个容器启动时要运行的命令（CMD替代先前命令，ENTRYPOINT在先前命令后追加）</td></tr><tr><td align="center">COPY</td><td align="center">类似于ADD，将文件拷贝到镜像中</td></tr><tr><td align="center">ENV</td><td align="center">构建时设置环境变量</td></tr></tbody></table><h3 id="3-构建自己的CentOS"><a href="#3-构建自己的CentOS" class="headerlink" title="3 构建自己的CentOS"></a>3 构建自己的CentOS</h3><p>下载CentOS基础镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull centos:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建dockerfile文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> mydockerfile-centos<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>写dockerfile文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#选择基础镜像。centos8 21年的时候停止了源服务，因此yum命令会报错。这里直接指定7版本</span>FROM centos:7<span class="token comment">#作者信息</span>MAINTAINER qjk<span class="token operator">&lt;</span><span class="token number">1256929691</span>@qq.com<span class="token operator">></span><span class="token comment">#环境变量</span>ENV MYPATH /usr/local<span class="token comment">#进入容器时的目录</span>WORKDIR <span class="token variable">$MYPATH</span><span class="token comment">#需要运行的命令</span>RUN yum -y <span class="token function">install</span> <span class="token function">vim</span>RUN yum -y <span class="token function">install</span> net-tools<span class="token comment">#暴露端口</span>EXPOSE <span class="token number">8888</span><span class="token comment">#输出一些信息</span>CMD <span class="token builtin class-name">echo</span> <span class="token variable">$MYPATH</span>CMD <span class="token builtin class-name">echo</span> <span class="token string">"---end---"</span><span class="token comment">#运行bash</span>CMD /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构建镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#-f 使用的dockerfile文件 -t 镜像名:版本号 . 当前上下文环境</span><span class="token function">docker</span> build -f mydockerfile-centos -t mycentos:1.0 <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it mycentos:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试发现安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@d92186b194dc local<span class="token punctuation">]</span><span class="token comment"># ifconfig </span>eth0: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">416</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu <span class="token number">1500</span>        inet <span class="token number">172.17</span>.0.2  netmask <span class="token number">255.255</span>.0.0  broadcast <span class="token number">172.17</span>.255.255        ether 02:42:ac:11:00:02  txqueuelen <span class="token number">0</span>  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets <span class="token number">8</span>  bytes <span class="token number">656</span> <span class="token punctuation">(</span><span class="token number">656.0</span> B<span class="token punctuation">)</span>        RX errors <span class="token number">0</span>  dropped <span class="token number">0</span>  overruns <span class="token number">0</span>  frame <span class="token number">0</span>        TX packets <span class="token number">0</span>  bytes <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span> B<span class="token punctuation">)</span>        TX errors <span class="token number">0</span>  dropped <span class="token number">0</span> overruns <span class="token number">0</span>  carrier <span class="token number">0</span>  collisions <span class="token number">0</span>lo: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">7</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,LOOPBACK,RUNNING<span class="token operator">></span>  mtu <span class="token number">65536</span>        inet <span class="token number">127.0</span>.0.1  netmask <span class="token number">255.0</span>.0.0        loop  txqueuelen <span class="token number">1000</span>  <span class="token punctuation">(</span>Local Loopback<span class="token punctuation">)</span>        RX packets <span class="token number">0</span>  bytes <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span> B<span class="token punctuation">)</span>        RX errors <span class="token number">0</span>  dropped <span class="token number">0</span>  overruns <span class="token number">0</span>  frame <span class="token number">0</span>        TX packets <span class="token number">0</span>  bytes <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span> B<span class="token punctuation">)</span>        TX errors <span class="token number">0</span>  dropped <span class="token number">0</span> overruns <span class="token number">0</span>  carrier <span class="token number">0</span>  collisions <span class="token number">0</span><span class="token punctuation">[</span>root@localhost data<span class="token punctuation">]</span><span class="token comment"># docker history mycentos:1.0</span>IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT68ec40605859   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  CMD ["/bin/sh" "-c" "/bin…   0B        </span>a611dbac6ce6   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  CMD ["/bin/sh" "-c" "echo…   0B        </span>3760049dc190   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  CMD ["/bin/sh" "-c" "echo…   0B        </span>8a9d3aecc1fb   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  EXPOSE 8888                  0B        </span>ba8c71fa6dde   <span class="token number">21</span> minutes ago   /bin/sh -c yum -y <span class="token function">install</span> net-tools             171MB     1de039243935   <span class="token number">21</span> minutes ago   /bin/sh -c yum -y <span class="token function">install</span> <span class="token function">vim</span>                   226MB     7f9dde17bf22   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop) WORKDIR /usr/local            0B        </span>97ada81ddf08   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  ENV MYPATH=/usr/local        0B        </span>53e586d5ba0a   <span class="token number">22</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  MAINTAINER qjk&lt;1256929691…   0B        </span>eeb6ee3f44bd   <span class="token number">9</span> months ago     /bin/sh -c <span class="token comment">#(nop)  CMD ["/bin/bash"]            0B        </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">9</span> months ago     /bin/sh -c <span class="token comment">#(nop)  LABEL org.label-schema.sc…   0B        </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">9</span> months ago     /bin/sh -c <span class="token comment">#(nop) ADD file:b3ebbe8bd304723d4…   204MB     </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-CMD和ENTRYPOINT的区别"><a href="#4-CMD和ENTRYPOINT的区别" class="headerlink" title="4 CMD和ENTRYPOINT的区别"></a>4 CMD和ENTRYPOINT的区别</h3><p>例如dockerfile中使用CMD命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">CMD <span class="token punctuation">[</span><span class="token string">"ls"</span>,<span class="token string">"-a"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>后续启动容器时想要执行<code>ls -l</code>命令，这样写会报错</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it mycentos:1.0 -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为<code>-l</code>会直接替换ls -a，正确的写法是这样</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it mycentos:1.0 <span class="token function">ls</span> -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如dockerfile中使用ENTRYPOINT命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"ls"</span>,<span class="token string">"-a"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样写就不会报错</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it mycentos:1.0 -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-构建Tomcat"><a href="#5-构建Tomcat" class="headerlink" title="5 构建Tomcat"></a>5 构建Tomcat</h3><p>Dockerfile文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FROM centos  COPY readme.md /usr/local/readme.md<span class="token comment">#添加压缩包，docker会自动解压</span>ADD jdk8.tar.gz /usr/localADD tomcat.tar.gz /usr/localRUN yum -y <span class="token function">install</span> <span class="token function">vim</span>ENV MYPATH /usr/localWORKDIR <span class="token variable">$MYPATH</span>ENV JAVA_HOME /usr/local/jdk1.8.0_141ENV CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jarENV <span class="token environment constant">PATH</span> <span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$JAVA_HOME</span>/binEXPOSE <span class="token number">8080</span><span class="token comment">#命令可以用&amp;&amp;直接拼接</span>CMD /usr/local/apache-tomcat-10.0.12/bin/startup.sh <span class="token operator">&amp;&amp;</span> <span class="token function">tail</span> -F /usr/local/apache-tomcat-10.0.12/bin/logs/catalina.out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-发布镜像"><a href="#6-发布镜像" class="headerlink" title="6 发布镜像"></a>6 发布镜像</h3><blockquote><p>dockerhub</p></blockquote><ol><li>注册dockerhub账号</li><li>登录dockerhub</li><li>发布</li></ol><p>登录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> login -u 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过<code>tag</code>创建版本号</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> tag 镜像名<span class="token operator">|</span><span class="token function">id</span> 新的镜像名:版本号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发布</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> push 镜像名:版本号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="九-Docker网络"><a href="#九-Docker网络" class="headerlink" title="九 Docker网络"></a>九 Docker网络</h2><h3 id="1-Docker0"><a href="#1-Docker0" class="headerlink" title="1 Docker0"></a>1 Docker0</h3><p>通过命令<strong>ip addr</strong>查看本地ip地址，我们发现除了本机回环地址和埃里远的内网地址外，还多了一个网卡：Docker0，这是Docker服务启动后自动生成的。</p><p>而如果进入一个正在后台运行的tomcat容器，同样使用<strong>ip addr</strong>命令，发现容器得到了一个新的网络：<strong>12: eth@if13</strong>，ip地址：<strong>172.17.0.2</strong>。这是Docker在容器启动时为其分配的。</p><p>docker容器的网络是通过<code>veth</code>（Linux提供的虚拟网卡接口）来管理的。宿主机和容器分别连接到一个虚拟网卡接口。例如：宿主机一个新网络<strong>13: vethda1df4b@if12</strong>，对应容器内网络地址的<strong>12: eth@if13</strong>。12和13分别是宿主机端和容器端的接口编号。宿主机和容器之间可以ping通，容器与容器间也可以ping通，会通过docker0转发，docker0类似于局域网中的路由器。</p><p><img src="http://img.meditate.eu.org/note/image-20220624095350600.png" alt="image-20220624095350600"></p><p>容器一删除，对应的网桥也会随之删除。</p><h3 id="2-–link"><a href="#2-–link" class="headerlink" title="2 –link"></a>2 –link</h3><blockquote><p>若编写一个微服务并连接数据库，如果数据库ip改变，如何根据容器名而不是ip访问容器？显然，直接使用容器名是无法ping通容器内部的：</p></blockquote><p>这时我们可以在容器启动命令中加入一个选项：<strong>–link</strong>，使得我们可以根据容器名来访问容器。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d -P --link 容器名/id 镜像名/id<span class="token comment">#例如:启动一个容器并与tomcat01进行相连</span><span class="token function">docker</span> run -d -P --link tomcat01 --name tomcat02 tomcat:8 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>连接后，tomcat02可以直接ping tomcat01，而<strong>tomcat01却不能ping通tomcat02</strong>。</p><p>实现原理：在tomcat02的host文件中添加了tomcat01的ip地址。</p><p>显然这种方式过于低级，无法解决上述问题，因此–link不建议使用。</p><p>在实际开发中，docker0网卡的局限性过大，不支持服务名访问，因此往往会使用自己的网卡代替docker0。</p><h3 id="3-自定义网络"><a href="#3-自定义网络" class="headerlink" title="3 自定义网络"></a>3 自定义网络</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看所有的docker网络</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker network ls</span>NETWORK ID     NAME      DRIVER    SCOPE8d9e97cd0f61   bridge    bridge    <span class="token builtin class-name">local</span>7d43eef7b13e   <span class="token function">host</span>      <span class="token function">host</span>      <span class="token builtin class-name">local</span>bc1e545c960e   none      null      <span class="token builtin class-name">local</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>docker中的网络模式有：</p><ul><li>bridge：桥接（docker默认）/</li><li>none：不配置网络 /</li><li>host：和宿主机共享网络</li></ul><p><code>docker run </code>命令默认带有一个参数–net bridge，此处的bridge指的就是docker0。可以自己手动创建一个新的网络。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span>  network create --driver 网络模式 --subnet 子网ip --gateway 网关 网络名     <span class="token comment">#例如</span><span class="token function">docker</span>  network create --driver bridge --subnet <span class="token number">192.168</span>.1.0/16 --gateway <span class="token number">192.168</span>.1.1 mynet     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>创建容器并使用自己创建的网络。这样创建的容器可以通过ping容器名直接ping通。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d --name tomcat01 -net mynet tomcat:8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-网络连通"><a href="#4-网络连通" class="headerlink" title="4 网络连通"></a>4 网络连通</h3><p>对于建立在不同网络下(docker0, newnet)的两个容器tomcat01和tomcat02，他们的网段不同，因此是无法彼此ping通容器内部的：</p><p>这时我们需要通过docker network connect命令打通容器与网络之间的连接：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> network connect 网络名 容器名/id例如：<span class="token function">docker</span> network connect mynet tomcat01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十-springboot微服务打包成镜像"><a href="#十-springboot微服务打包成镜像" class="headerlink" title="十  springboot微服务打包成镜像"></a>十  springboot微服务打包成镜像</h2><p>打包成jar包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mvn package<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编写Dockerfile</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FROM java:8COPY *.jar /app.jarCMD <span class="token punctuation">[</span><span class="token string">"--server.port=8080"</span><span class="token punctuation">]</span>EXPOSE <span class="token number">8080</span>ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"java"</span>,<span class="token string">"-jar"</span>,<span class="token string">"app.jar"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构建镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1.复制jar和DockerFIle到服务器</span><span class="token comment"># 2.构建镜像</span><span class="token function">docker</span> build -t xxxxx:xx  <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>壁纸</title>
      <link href="/2022/06/10/resource/bi-zhi/"/>
      <url>/2022/06/10/resource/bi-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="壁纸网站推荐"><a href="#壁纸网站推荐" class="headerlink" title="壁纸网站推荐"></a>壁纸网站推荐</h1><h2 id="极简壁纸"><a href="#极简壁纸" class="headerlink" title="极简壁纸"></a>极简壁纸</h2><p><a href="https://bz.zzzmh.cn/index">https://bz.zzzmh.cn/index</a></p><p>一个中文的壁纸网站，壁纸质量很高，分类不太方便，适合桌面端。</p><h2 id="anime-pictures"><a href="#anime-pictures" class="headerlink" title="anime-pictures"></a>anime-pictures</h2><p><a href="https://anime-pictures.net/pictures/view_posts/0?lang=zh_CN">https://anime-pictures.net/pictures/view_posts/0?lang=zh_CN</a></p><p>一个插画分享网站，全世界的画师可以在这个网站分享作品。主要以动漫人物为主。</p><h2 id="wallhaven"><a href="#wallhaven" class="headerlink" title="wallhaven"></a>wallhaven</h2><p><a href="https://wallhaven.cc/">https://wallhaven.cc/</a></p><p>最强大的壁纸网站，分类功能完善，壁纸种类弃齐全。</p><h2 id="wallpaperscraft"><a href="#wallpaperscraft" class="headerlink" title="wallpaperscraft"></a>wallpaperscraft</h2><p><a href="https://wallpaperscraft.com/">https://wallpaperscraft.com/</a></p><p>壁纸种类多，但是质量不怎么样。可以自定义壁纸的尺寸。</p><h2 id="wallpaperhub"><a href="#wallpaperhub" class="headerlink" title="wallpaperhub"></a>wallpaperhub</h2><p><a href="https://wallpaperhub.app/">https://wallpaperhub.app/</a></p><p>主要是收集了一些产品的官方壁纸，比如Windows11，surface等。</p><h2 id="wallpaper-abyss"><a href="#wallpaper-abyss" class="headerlink" title="wallpaper abyss"></a>wallpaper abyss</h2><p><a href="https://wall.alphacoders.com/">https://wall.alphacoders.com/</a></p><p>可以选择简体中文。搜索功能强大，输入关键词后可以很快找到想要的壁纸，壁纸也非常多。</p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 壁纸 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
