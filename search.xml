<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【论文阅读】Distral Robust Multitask Reinforcement Learning</title>
      <link href="/2022/09/15/ml/lun-wen-yue-du-distral-robust-multitask-reinforcement-learning/"/>
      <url>/2022/09/15/ml/lun-wen-yue-du-distral-robust-multitask-reinforcement-learning/</url>
      
        <content type="html"><![CDATA[<p>本文提出了一种同时在多个任务上训练的强化学习方法，叫做Distral。主要的想法是把各个任务上学到的策略进行提纯（distill，本意是蒸馏）得到一个共有的策略，然后再使用这个共有的策略去指导各个特定任务上的策略进行更好的学习。文章称，这种多任务的强化学习方法避免了不同任务产生互斥的梯度，反而干扰学习；同时，也避免了各个任务学习进度不一致，导致某个任务的学习主导了整体的学习。</p><p>这个视频讲得不错，但是有一些错误，以自己笔记为准： https://www.bilibili.com/video/BV1PQ4y1M7nG?share_source=copy_web&amp;vd_source=f038e298fba3a40848f18a2c0868db34</p><p>可以结合这篇文章来看：https://zhuanlan.zhihu.com/p/51091244</p><p>关于蒸馏学习，简单来说就是把一个模型的内容提炼到一个新的模型。可以看这篇：https://zhuanlan.zhihu.com/p/258390817</p><h1 id="distral">Distral</h1><h2 id="模型架构">模型架构</h2><figure><img src="http://img.meditate.eu.org/note/image-20220915152930481.png" alt="" /><figcaption>Distral架构</figcaption></figure><p><span class="math inline">\(\pi_0\)</span>是一个公共策略，是从<span class="math inline">\(\pi_1,\pi_2,\pi_3,\pi_4\)</span>中蒸馏出来的一个<strong>中心策略</strong>。得到<span class="math inline">\(\pi_0\)</span>后会用来指导<span class="math inline">\(\pi_1,\pi_2,\pi_3,\pi_4\)</span>这四个不同的任务的策略。作者说这种基于蒸馏和迁移学习的多任务学习方式效果优于共享模型权重的方式。</p><h2 id="目标函数">目标函数</h2><p><span class="math display">\[\begin{aligned}J\left(\pi_0,\left\{\pi_i\right\}_{i=1}^n\right) &amp;=\sum_i \mathbb{E}_{\pi_i}\left[\sum_{t \geq 0} \gamma^t R_i\left(a_t, s_t\right)-c_{\mathrm{KL}} \gamma^t \log \frac{\pi_i\left(a_t \mid s_t\right)}{\pi_0\left(a_t \mid s_t\right)}-c_{\mathrm{Ent}} \gamma^t \log \pi_i\left(a_t \mid s_t\right)\right] \\&amp;=\sum_i \mathbb{E}_{\pi_i}\left[\sum_{t \geq 0} \gamma^t R_i\left(a_t, s_t\right)+\frac{\gamma^t \alpha}{\beta} \log \pi_0\left(a_t \mid s_t\right)-\frac{\gamma^t}{\beta} \log \pi_i\left(a_t \mid s_t\right)\right]\end{aligned}\]</span></p><p>作者构造了上面这个目标函数，那么我们希望最大化这个目标函数。其中<span class="math inline">\(\alpha =\frac{c_{\text{KL}}}{c_{\text{KL}}+c_{\text{Ent}}}\)</span>，<span class="math inline">\(\beta=\frac{1}{c_\text{KL}+c_\text{Ent}}\)</span>，<span class="math inline">\(c_\text{KL}\)</span>和<span class="math inline">\(c_\text{Ent}\)</span>是决定KL和熵正则化强度的大小的标量因子，二者都是大于0的。</p><p>解释一下额外添加的两项的作用：</p><p><strong>KL散度项正则化项：</strong><span class="math inline">\(c_{\mathrm{KL}} \gamma^t \log \frac{\pi_i\left(a_t \mid s_t\right)}{\pi_0\left(a_t \mid s_t\right)}\)</span>。约束了各个策略<span class="math inline">\(\pi_i\)</span>不要离中心策略<span class="math inline">\(\pi_0\)</span>太远。KL散度衡量了两个分布之间的差异，两个分布完全一致，散度就为0。否则散度较大。这里减去散度项，在使<span class="math inline">\(J\)</span>尽可能大时，散度项就要尽可能小。</p><p><strong>熵正则化项：</strong><span class="math inline">\(-c_{\mathrm{Ent}} \gamma^t \log \pi_i\left(a_t \mid s_t\right)\)</span>。鼓励探索，避免策略只会收敛到解决那个简单的任务。作者举了一个例子：在多任务场景下，如果有一个任务特别的简单，获得奖励非常容易。那么在没有熵正则化项的情况下，模型会收敛到解决那个简单任务然后不再去探索其他较难的任务。这会导致次优策略。这里这个熵项省略了一个乘数，不过并不影响理解它。因为熵的展开本身就存在一个负号，这里其实可以把负号看成一个整体，相当于加上了一个熵项。熵项越大说明策略不确定越高，越鼓励探索，与最大<span class="math inline">\(J\)</span>的目标一致。</p><p>（正则化项：约束优化朝我们想要的方向前进）</p><h2 id="两种优化方式">两种优化方式</h2><h3 id="交替优化">交替优化</h3><p>交替优化就是指先蒸馏一个中心策略，再用中心策略去指导其他的任务。这样依次交替强化两种策略。</p><h4 id="固定pi_i优化pi_0">固定<span class="math inline">\({\pi_i}\)</span>优化<span class="math inline">\(\pi_0\)</span></h4><p>这实际上就是一个蒸馏过程，此时<span class="math inline">\(\pi_i\)</span>项为常数，只需要最大化箭头右边的那项即可。可以用策略梯度等方法。</p><figure><img src="http://img.meditate.eu.org/note/image-20220915162252682.png" alt="" /><figcaption>蒸馏过程</figcaption></figure><h4 id="固定pi_0优化pi_i">固定<span class="math inline">\({\pi_0}\)</span>优化<span class="math inline">\(\pi_i\)</span></h4><p>这样可以对每个<span class="math inline">\(\pi_i\)</span>单独优化，可其看成一个附加熵项的单任务强化学习。推导过程如下：</p><figure><img src="http://img.meditate.eu.org/note/46126295643600.png" alt="" /><figcaption>推一下带熵的reward函数</figcaption></figure><p>这样奖励函数可以用soft Q Learning优化（详见自己的笔记）。</p><figure><img src="http://img.meditate.eu.org/note/46767864258564.png" alt="" /><figcaption>套用SQL的细节</figcaption></figure><p>所以可以套用SQL的Q和V。带进去推一遍即可，得到Q和V。 <span class="math display">\[\begin{aligned}V_i\left(s_t\right) &amp;=\frac{1}{\beta} \log \sum_{a_t} \pi_0^\alpha\left(a_t \mid s_t\right) \exp \left[\beta Q_i\left(a_t, s_t\right)\right] \\Q_i\left(a_t, s_t\right) &amp;=R_i\left(a_t, s_t\right)+\gamma \sum p_i\left(s_{t+1} \mid s_t, a_t\right) V_i\left(s_{t+1}\right)\end{aligned}\]</span> 可以推出<span class="math inline">\(\pi_i\)</span></p><figure><img src="http://img.meditate.eu.org/note/49077424938724.png" alt="" /><figcaption>推导策略i</figcaption></figure><h3 id="联合优化">联合优化</h3><p>依次对<span class="math inline">\(\pi_i\)</span>和<span class="math inline">\(\pi_0\)</span>做SGD，最大化目标函数。联合优化比较简单</p><h4 id="更好的策略表示">更好的策略表示</h4><p><span class="math inline">\(\pi_0\)</span>的估计可以使用简单的玻尔兹曼策略表示，这里的<span class="math inline">\(h_\theta(a_t|s_t)\)</span>就是代表<span class="math inline">\(Q_\theta\)</span> <span class="math display">\[\hat{\pi}_0\left(a_t \mid s_t\right)=\frac{\exp \left(h_{\theta_0}\left(a_t \mid s_t\right)\right.}{\sum_{a^{\prime}} \exp \left(h_{\theta_0}\left(a^{\prime} \mid s_t\right)\right)}\]</span> 对于<span class="math inline">\(\pi_i\)</span>，作者提出了一个更好的表示方式。用<span class="math inline">\(\pi_0\)</span>的共有部分和自己的特有部分来表示。</p><p><img src="http://img.meditate.eu.org/note/image-20220915175805274.png" alt="更好的策略表示" /> <span class="math display">\[\hat{\pi}_i\left(a_t \mid s_t\right)=\hat{\pi}_0^\alpha\left(a_t \mid s_t\right) \exp \left(\beta \hat{A}_i\left(a_t \mid s_t\right)\right)=\frac{\exp \left(\alpha h_{\theta_0}\left(a_t \mid s_t\right)+\beta f_{\theta_i}\left(a_t \mid s_t\right)\right)}{\sum_{a^{\prime}} \exp \left(\left(\alpha h_{\theta_0}\left(a^{\prime} \mid s_t\right)+\beta f_{\theta_i}\left(a^{\prime} \mid s_t\right)\right)\right.}\]</span></p><h4 id="策略梯度">策略梯度</h4><p>于是就利用策略梯度对<span class="math inline">\(\pi_i\)</span>和<span class="math inline">\(\pi_0\)</span>分别优化。 <span class="math display">\[\begin{aligned}\nabla_{\theta_i} J &amp;=\mathbb{E}_{\hat{\pi}_i}\left[\left(\sum_{t \geq 1} \nabla_{\theta_i} \log \hat{\pi}_i\left(a_t \mid s_t\right)\right)\left(\sum_{u \geq 1} \gamma^u\left(R_i^{\mathrm{reg}}\left(a_u, s_u\right)\right)\right)\right] \\&amp;=\mathbb{E}_{\hat{\pi}_i}\left[\sum_{t \geq 1} \nabla_{\theta_i} \log \hat{\pi}_i\left(a_t \mid s_t\right)\left(\sum_{u \geq t} \gamma^u\left(R_i^{\mathrm{reg}}\left(a_u, s_u\right)\right)\right)\right]\end{aligned}\]</span> 其中：<span class="math inline">\(R_i^{\operatorname{reg}}(a, s)=R_i(a, s)+\frac{\alpha}{\beta} \log \hat{\pi}_0(a \mid s)-\frac{1}{\beta} \log \hat{\pi}_i(a \mid s)\)</span> <span class="math display">\[\begin{aligned}\nabla_{\theta_0} J=&amp; \sum_i \mathbb{E}_{\hat{\pi}_i}\left[\sum_{t \geq 1} \nabla_{\theta_0} \log \hat{\pi}_i\left(a_t \mid s_t\right)\left(\sum_{u \geq t} \gamma^u\left(R_i^{\mathrm{reg}}\left(a_u, s_u\right)\right)\right]\right.\\&amp;+\frac{\alpha}{\beta} \sum_i \mathbb{E}_{\hat{\pi}_i}\left[\sum_{t \geq 1} \gamma^t \sum_{a_t^{\prime}}\left(\hat{\pi}_i\left(a_t^{\prime} \mid s_t\right)-\hat{\pi}_0\left(a_t^{\prime} \mid s_t\right)\right) \nabla_{\theta_0} h_{\theta_0}\left(a_t^{\prime} \mid s_t\right)\right]\end{aligned}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Multi-Objective Congestion Control</title>
      <link href="/2022/09/10/ml/lun-wen-yue-du-multi-objective-congestion-control/"/>
      <url>/2022/09/10/ml/lun-wen-yue-du-multi-objective-congestion-control/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是==首篇将多目标强化学习算法应用到拥塞控制（CC）==的一篇偏应用的文章。现有的CC算法无法应对不同程序的新的需求，当应对新的应用时需要学习一个新模型，作者提出了MOCC多目标强化学习框架。在这个框架下，MOCC 进一步应用迁移学习将知识从过去的经验转移到新的应用程序中，即使是不可预见的，也能快速适应新的目标。</p><p>MOCC 明确地将性能目标纳入状态输入和动态奖励函数，并利用带有偏好子网络的新策略神经网络将不同目标与最优控制策略相关联。这允许 MOCC 有效地建立一个单一的相关模型来支持不同的性能目标。在此框架下，MOCC 进一步应用迁移学习，将过去经验中学到的知识快速迁移到新的应用程序中，并针对给定的目标优化 CC 算法。</p><p><strong>总结一下：</strong>就是先预训练一个全局的普适模型，再根据每个应用的需求在应用上迅速地迭代，得到一个应用专属的CC。</p><p>这篇文章的多目标体现在，吞吐量，延迟等目标，不同应用对于这些目标的需求不同。本质上是多目标问题，与应用无关。<strong>感觉有点套了多目标的一个壳子，实际上就是一个简单的标量多目标问题，然后想办法让它适应不同的目标权重组合。</strong></p><h1 id="mocc">MOCC</h1><p>MOCC结合了离线训练和在线学习。离线训练：MOCC在一组分布良好的目标上学习，将性能目标纳入状态输入和动态奖励函数，了解应用程序需求和最优策略之间的相关性。在线学习：面对新应用应用迁移学习经过几次迭代快速收敛到最优策略。</p><h2 id="模型架构">模型架构</h2><p>MOCC 对标准的基于 RL 的 CC 进行了两个主要更改：（1）将偏好子网络合并到策略网络中；（2）在状态输入和动态奖励功能中包括应用需求。这样，MOCC就可以建立各种应用需求和相应的最优码率控制策略之间的关联。</p><h3 id="模型输入">模型输入</h3><p>模型的输入包含了<strong>网络的状态</strong>以及<strong>应用对于不同指标的需求</strong>。</p><ol type="1"><li>应用对于不同指标的需求</li></ol><p>这个需求用一个权重向量表示<span class="math inline">\(\vec{w}=&lt;w_{thr},w_{lat},w_{loss}&gt;\)</span>，$w_i( 0,1 ) <span class="math inline">\(，\)</span>=1$。分别代表吞吐量、延迟和丢包率的权重。</p><ol start="2" type="1"><li>网络的状态</li></ol><p>模型的状态<span class="math inline">\(\vec{g}=&lt;l_t,p_t,q_t&gt;\)</span></p><p><span class="math inline">\(l_t\)</span>：发送率。定义为发送方发送的数据包超过接收方确认的数据包</p><p><span class="math inline">\(p_t\)</span>：潜伏期比率。当前时间间隔𝑡的平均潜伏期与历史上观察到的最小平均潜伏期之比</p><p><span class="math inline">\(q_t\)</span>：延迟梯度。延迟时间对时间的导数</p><p>为了了捕捉网络动态的趋势和变化，模型使用==固定长度的网络统计历史==而不是最近的历史<strong>作为网络的输入</strong>:</p><p><span class="math display">\[\vec{g}_{(t,\eta)}=&lt;\vec{g}_{t-\eta},\vec{g}_{t-\eta+1},\cdots,\vec{g}_{t}&gt;\]</span></p><h3 id="输出">输出</h3><p>actor输出的是一个概率分布，agent挑选一个<span class="math inline">\(a_t\)</span>，网络发送速率<span class="math inline">\(x_t\)</span>的变化如下： <span class="math display">\[x_t=\left\{ \begin{array}{l}    x_{t-1}\times \left( 1+\alpha a_t \right) \ a_t&gt;0\\    x_{t-1}/\left( 1-\alpha a_t \right) \ \ a_t&lt;0\\\end{array} \right.\]</span> 这里 𝛼 是用于抑制振荡的比例因子。代替离散发送速率调整，我们选择连续发送速率调整以提高模型鲁棒性并实现更快的收敛。</p><h3 id="奖励函数">奖励函数</h3><p><span class="math display">\[r_t=w_{thr}*O_{thr}+w_{lat}*O_{lat}+w_{loss}*O_{loss}\]</span></p><p><span class="math inline">\(O_{thr}=\frac{\text{Measured\,\,Throughput}}{\text{Linked\,\,Capacity}}\)</span>，<span class="math inline">\(O_{lat}=\frac{\text{Base Link Latency}}{\text{Measured Latency}}\)</span>，<span class="math inline">\(O_{loss}=1-\frac{\text{Lost Packets}}{\text{Total Packets}}\)</span>，都定义为与奖励正相关，并且除以一个大数是为了标准化到<span class="math inline">\([0,1]\)</span>。</p><h3 id="模型结构">模型结构</h3><p>采用actor-critic的结构，两个模型都引入了==偏好子网络==。</p><figure><img src="http://img.meditate.eu.org/note/image-20220910144043721.png" alt="" /><figcaption>image-20220910144043721</figcaption></figure><h1 id="训练">训练</h1><h2 id="离线训练">离线训练</h2><p>显然，目标空间是无限的，为了高效训练MOCC，文章没有探索整个目标空间，而是在标志性目标的子集上进行训练。</p><p>这一过程分为两个阶段：bootstrapping（引导）and fast traversing （快速遍历）</p><h3 id="bootstrapping">bootstrapping</h3><p>选择一些bootstrapping的权重向量，也就是<strong>自定义一些权重向量</strong>。这些权重向量应当尽量有代表性，文章中是选取了3个不同的权重向量（目标），先在这三个上训练出了一个基础的模型。作者说这一过程需要花费数个小时。</p><p>文章中使用的3个bootstrapping目标为：<span class="math inline">\(&lt;0.6,0.3,0.1&gt;,&lt;0.1,0.6,0.3&gt;,&lt;0.3,0.6,0.1&gt;\)</span></p><p>==值得注意的是：这篇文章中的objectives的定义似乎和我理解的不一样，我理解的是吞吐量、延迟和丢包率是三个目标，而这篇文章中似乎把一个不同的权重向量<span class="math inline">\(\vec{w}=&lt;w_{thr},w_{lat},w_{loss}&gt;\)</span>称为一个目标。详见文章的4.2小节。==</p><h3 id="fast-traversing">fast traversing</h3><p>在快速遍历阶段，在基础模型的基础上，我们通过采用基于邻域的迁移学习策略来加速剩余的 𝜔-3 目标的训练 。该方法基于以下观察：==当两个 RL 具有相近的目标（即相似的权重向量）时，它们的最优解相近。==因此，在训练 RL 时，我们可以通过利用其相邻 RL 的解决方案来加速。</p><p>文章从一个目标迭代训练到它的neighbor，并以循环方式遍历所有目标。请注意，<strong>每次不会将一个权重向量训练到收敛，而只训练几个步骤以实现所有目标的平衡改进。</strong>当模型收敛到所有目标时，整个训练就完成了。如图所示：</p><figure><img src="http://img.meditate.eu.org/note/1662795553488.png" alt="" /><figcaption>1662795553488</figcaption></figure><h4 id="neighbor的定义">neighbor的定义</h4><p>两个权重向量定义为邻居，如果它们最多在两个维度上不同并且每个维度的差异小于步长。例如，在步长为 0.1 时，&lt;0.2, 0.4, 0.4&gt; 和 &lt;0.2, 0.5, 0.3&gt; 是邻居，&lt;0.2, 0.4, 0.4&gt; 和 &lt;0.1, 0.5, 0.4&gt; 是邻居，但 &lt;0.2, 0.4, 0.4&gt; 和 &lt;0.1, 0.3, 0.6&gt; 不是邻居。我们在邻居之间添加边并将所有边权重设置为 1</p><h4 id="查找neighbor">查找neighbor</h4><p>查找neighbor使用的是dijkstra算法</p><p>𝐿 包含一个排序的目标列表，可以用作MOCC 模型的训练顺序</p><p><img src="http://img.meditate.eu.org/note/42692839774128.jpg" alt="42692839774128" style="zoom:55%;" /></p><h3 id="策略优化算法">策略优化算法</h3><p>使用PPO-Clip来训练MOCC <span class="math display">\[L^{CLIP}\left( \theta ,\vec{w} \right) _t=\hat{\mathbb{E}}_t\left[ \min \left( r_t\left( \theta \right) \hat{A}_t,clip\left( r_t\left( \theta \right) ,1-\epsilon ,1+\epsilon \right) \right) \hat{A}_t \right]\]</span></p><p><span class="math inline">\(r_t(\theta)=\frac{\pi_\theta\left(a_t \mid \vec{v}_{(t, \eta)}, \vec{w}\right)}{\pi_{\theta_{o l d}}\left(a_t \mid \vec{v}_{(t, \eta)}, \vec{w}\right)}\)</span>，<span class="math inline">\(\hat{A}\left(\vec{g}_{(t, \eta)}, \vec{w}, a_t\right)=\sum_t \gamma^t r_t-V^{\pi_\theta}\left(\vec{g}_{(t, \eta)}, \vec{w}\right)\)</span>其中<span class="math inline">\(V^{\pi _{\theta}}\left( \vec{g}_{\left( t,\eta \right)},\vec{w} \right)\)</span>是一个惩罚项，为了使奖励不能始终为正，它是有critic网络估计的。</p><p>为了鼓励对策略网络的探索，正如过去的工作 [38] 中所建议的，我们在目标函数<span class="math inline">\(L^{CLIP}\)</span>中添加了一个熵正则化项： <span class="math display">\[L_t^{C L I P+E}(\theta, \vec{w})=L^{C L I P}(\theta, \vec{w})+\beta H\left(\pi_\theta(\cdot \mid \vec{g}(t, \eta), \vec{w})\right)\]</span></p><h2 id="在线调整">在线调整</h2><p>对于一个新应用，基础模型可以给出一个不错的CC方案，同时也可以通过迁移学习迭代少量次数做到很快适应应用，4.8分钟。</p><p>有一个问题：我们不想在适应新应用的同时牺牲旧应用的性能。与所有目标都是人工生成且均匀分布的离线训练不同，真实环境中的目标分布可能存在偏差：有些应用非常频繁，有些则很少见。在这种偏差下，传统的 RL 算法会过度拟合那些新的频繁应用，而逐渐忘记那些旧的稀有应用，这是不可取的。</p><p>为了避免这个问题，MOCC 使用了需求重放学习算法 。在线学习过程中，MOCC 存储长期遇到的应用（权重向量）。对于每个在线训练步骤，模型都在<strong>当前目标</strong>和从<strong>存储的应用程序池</strong>中随机抽取的旧目标上进行训练。将在线学习目标定义为： <span class="math display">\[L_{\text {online }}(\theta)=\frac{1}{2} *\left[L^{C L I P+E}\left(\theta, \vec{w}_i\right)+L^{C L I P+E}\left(\theta, \vec{w}_j\right)\right]\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多目标强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Multi-Task Reinforcement Learning with Soft Modularization</title>
      <link href="/2022/08/25/ml/lun-wen-yue-du-multi-task-reinforcement-learning-with-soft-modularization/"/>
      <url>/2022/08/25/ml/lun-wen-yue-du-multi-task-reinforcement-learning-with-soft-modularization/</url>
      
        <content type="html"><![CDATA[<p>将一个基础的网络分层并模块化，使用一个路由网络来为每个任务选择不同的模块，路由网络也可以学习。这就是所谓的软模块。</p><p>用到的是SAC算法的改进型，文中引用的确实最原始的SAC文章（坑死）。改进的SAC取缔了V网络，并且温度系数<span class="math inline">\(\alpha\)</span>不再固定死，而是通过梯度下降更新。<strong>SAC的温度系数自学版本没有完全理解，最好去看看。</strong></p><h1 id="soft-modularization">Soft Modularization</h1><figure><img src="http://img.meditate.eu.org/note/image-20220825211929434.png" alt="" /><figcaption>soft modularization</figcaption></figure><p>Base Policy有L层，每层由n个模块构成。Routing网络由L-1层的输出，每层都输出n*n的矩阵，代表了每个模块与下一层中模块之前连接的权重。<span class="math inline">\(s_t\)</span>代表当前状态，<span class="math inline">\(z_{\tau}\)</span>代表了与任务相关的one-hot编码。两个输入经过全连接层都会得到一个D维的向量，D在这里是一个超参数。</p><p>最后Base Policy输出的是<span class="math inline">\(\mu ,\sigma\)</span>代表一个分布。</p><p>不同任务的难易程度不同造成了收敛速度也不同。因此要在各个任务的损失函数前加个权重，这个权重与<span class="math inline">\(\alpha\)</span>相关。 <span class="math display">\[w_{i} =\frac{e^{-\alpha _{i} } }{\sum_{j=1}^{M} e^{-\alpha _{i}} }\]</span> 而<span class="math inline">\(\alpha\)</span>则是通过梯度下降更新的。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Multi-Task Deep Reinforcement Learning for Continuous Action Control</title>
      <link href="/2022/08/24/ml/lun-wen-yue-du-multi-task-deep-reinforcement-learning-for-continuous-action-control/"/>
      <url>/2022/08/24/ml/lun-wen-yue-du-multi-task-deep-reinforcement-learning-for-continuous-action-control/</url>
      
        <content type="html"><![CDATA[<p>本文基于机器人场景，提出了一种multi-DDPG的算法，将DDPG拓展到了多任务场景，使机器人能够学习多个连续的动作。并且引入mlpconv显著减少了模型参数量，将图像和传感器数据组合为输入。</p><h1 id="mlpconv">MLPConv</h1><h2 id="mlpconv-1">mlpconv</h2><figure><img src="http://img.meditate.eu.org/note/20210213230837584.png" alt="" /><figcaption>mlpconv的结构</figcaption></figure><p>一般卷积操作可以看成特征的提取操作，而一般卷积一层只相当于一个线性操作，所以其只能提取出线性特征。所以作者就想能否在卷积层后也加入一个MLP使得每层卷积操作能够提取非线性特征。而为了减少参数量，又用1*1的卷积层模拟了MLP</p><p>一个mlpconv卷积块是1个卷积后加<strong>两个</strong>1*1的卷积，但是每个1*1卷积后面都跟着一个ReLu, 所以可以引入更多的非线性。</p><p>这里的图画的是真的坑，这里的<span class="math inline">\(C_2\)</span>指的是1*1卷积核的数量，展开的这一个长条形的向量指的是同一个位置的像素在经过<span class="math inline">\(C_2\)</span>个卷积过后的值。中间的类似全连接的部分指的是1*1卷积，因为对同一个像素点施加不同的1*1卷积就类似于全连接的结构。也就是相当于在不同通道之间进行全连接，==而不是把特征图展平。==</p><h2 id="全局平均池化">全局平均池化</h2><p>mlpconv还提出了全局平均池化的概念。</p><p>Global Average Pooling主要为了解决全连接层参数过多的问题，早期对于分类问题，最后一个卷积层的 Feature Map 通常与全连接层连接，最后通过 <strong>softmax 逻辑回归分类</strong>。全连接层带来的问题就是参数空间过大，容易过拟合</p><p>global average pooling的概念非常简单，分类任务有多少个类别,就控制最终产生多少个feature map，也就是多少通道数。然后对于整个特征图做平均池化。就得到与通道数相等的类别数。</p><h1 id="multi-ddpg">Multi-DDPG</h1><figure><img src="http://img.meditate.eu.org/note/image-20220824144142878.png" alt="" /><figcaption>multi-DDPG结构</figcaption></figure><p>multi-DDPG是多Actor，单Critic的结构。也就意味着一个Critic要对所有的Actor打分。在Critic模型中，最后一个全连接层是非共享的，前面的部分都是对个Actor共享的。</p><figure><img src="http://img.meditate.eu.org/note/image-20220824144310836.png" alt="" /><figcaption>multi-DDPG算法流程</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Towards Impartial Multi-Task Learning</title>
      <link href="/2022/08/16/ml/lun-wen-yue-du-towards-impartial-multi-task-learning/"/>
      <url>/2022/08/16/ml/lun-wen-yue-du-towards-impartial-multi-task-learning/</url>
      
        <content type="html"><![CDATA[<p>文章主要提出了一种方法能够均衡的学习multi task learning问题，这种方法的优点是不需要对分布有任何假设，并且对gradient scale的过程是和训练过程同步的，同时文章发现对loss balance和gradients balance是互补的，因此提出了一种混合的方法能够更好平衡gradients和losses。</p><p>这篇文章的推导过程还是比较精妙的，我只看懂了70%。</p><h1 id="算法">算法</h1><p>MTL的问题中平衡方法分为loss balance和gradients balance两种，这篇文章综合了这两种方法。</p><p>详细解读过程可以看论文阅读的PDF。</p><figure><img src="http://img.meditate.eu.org/note/image-20220816171337469.png" alt="" /><figcaption>IMTL的算法过程</figcaption></figure><p>gradients balance在文章中提出的方法是IMTL-G，用来更新共享层的参数。</p><p>loss balance提出的方法是IMTL-L，通过认为构造scaled loss函数来达到目的。</p><p>文章中提出的scaled loss如下所示： <span class="math display">\[g\left( s \right) =e^sL\left( \theta \right) -s\]</span> 这个函数是关于s和<span class="math inline">\(\theta\)</span>的函数，s是缩放系数，<span class="math inline">\(\theta\)</span>是各个任务单独的权重，这样就可以在模型中分别求偏导来更新两个变量。</p><p>$L( ) <span class="math inline">\(是原始损失，\)</span>e^s$是为了将s映射到正实数。-s是正则化项，为了避免s找到负无穷的平凡解。</p><p>构造scaled loss的原因和过程可以看论文PDF。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Task Switching Network for Multi-task Learning</title>
      <link href="/2022/08/16/ml/lun-wen-yue-du-task-switching-network-for-multi-task-learning/"/>
      <url>/2022/08/16/ml/lun-wen-yue-du-task-switching-network-for-multi-task-learning/</url>
      
        <content type="html"><![CDATA[<p>这篇论文提出了任务交换网络（TSN），首次使用单编码器-单解码器的结构显著减少了参数量。</p><h1 id="tsn">TSN</h1><figure><img src="http://img.meditate.eu.org/note/image-20220808230903682.png" alt="" /><figcaption>TSN的总体结构</figcaption></figure><p>主干网络是Resnet-18，解码器中每一层会接受上一层中上采样后的特征图拼接上本层的特征图。</p><p>与以往的模型最大的区别在于输出后面只接了一个头（decoder）。做卷积之后利用这一个头去完成不同的任务。为了区分不同的任务，引入了Task Embedding，为每个任务得到一个<span class="math inline">\(l_{\tau}\)</span>向量通过某种方式区分不同的任务。输出通道数的选择也是有讲究的，一般<strong>取所有任务中所需输出的最大的通道数</strong>。这样对于其他的任务，可以沿通道执行平均池化来适应不同的任务。（多说一句，平均池化是没有参数的，所以不会增加额外的参数）</p><h2 id="task-embedding-network">Task Embedding Network</h2><p>这是一个得到<span class="math inline">\(l_{\tau}\)</span>向量的过程。如图中的左下角</p><p>首先，要为每个任务初始化一个d维的条件向量。根据执行的任务的不同，选择任务对应的向量<span class="math inline">\(v_{\tau}\)</span>。然后经过一个全连接层，输出一个<span class="math inline">\(l_{\tau}\)</span>，仍然为d维。 <span class="math inline">\(v_{\tau}\)</span>的选择有两种：</p><ol type="1"><li>不同的任务的条件向量是正交</li></ol><p><span class="math display">\[v_{\tau ^1}^Tv_{\tau ^2}=\begin{cases}    \frac{d}{T},&amp;       \tau _1=\tau _2\\    0,&amp;     otherwise\\\end{cases}\]</span></p><ol start="2" type="1"><li><span class="math inline">\(v_{\tau}\)</span>是高斯随机矩阵</li></ol><p><span class="math display">\[v_{\tau}\sim N\left( 0_d,\text{diag}\left( 1_d \right) \right)\]</span></p><h2 id="conditional-convolution-module">Conditional Convolution Module</h2><p>也就是A模块，其结构如图中右下角所示</p><p>输入的张量的通道数为c</p><p>上一步中得到的<span class="math inline">\(l_{\tau}\)</span>会经过两个全连接层，将d维的向量映射到c维去。这样会分别得到两个向量<span class="math inline">\(\gamma\)</span>和<span class="math inline">\(\beta\)</span>。</p><p>随后经过AdaIN函数，其中的<span class="math inline">\(\mu\)</span>代表均值，<span class="math inline">\(\sigma ^2\)</span>代表方差。</p><p>这两个值是通过Instance Normalization（IN）得到的。具体可见：https://blog.csdn.net/u011447962/article/details/117714531?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-117714531-blog-125660719.pc_relevant_show_downloadRating&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-117714531-blog-125660719.pc_relevant_show_downloadRating&amp;utm_relevant_index=2</p><p>简单来说就是对于每个通道内部求均值方差。 <span class="math display">\[AdaIN\left( \hat{x},\beta ,\gamma \right) =\gamma \frac{\left( \hat{x}-\mu \right)}{\sqrt{\sigma ^2}}+\beta\]</span> 所以这个式子就是做IN的过程。<span class="math inline">\(\gamma\)</span>和<span class="math inline">\(\beta\)</span>称为缩放系数和偏移量。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Multi-task Learning with Attention for End-to-end Autonomous Driving</title>
      <link href="/2022/08/16/ml/lun-wen-yue-du-multi-task-learning-with-attention-for-end-to-end-autonomous-driving/"/>
      <url>/2022/08/16/ml/lun-wen-yue-du-multi-task-learning-with-attention-for-end-to-end-autonomous-driving/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是自动驾驶领域的文章，自动驾驶领域往往有两类任务：<strong>感知环境</strong>（如：语义分割），<strong>驾驶决策</strong>（根据周围环境做出相应的操作）。</p><p>这篇文章聚焦于自动驾驶中的点对点的导航问题，将多任务学习引入了自动驾驶，并且引入了注意力机制有效提高了准确率，文末也通过可视化图热图对注意力机制进行了定性的分析。本文的模型能够识别红绿灯（以往的模型做不到）。</p><p><strong>这篇文章是基于RGB单目相机，并且是端到端的，采用了CIL框架</strong>。（端到端指的是输入是原始数据，输出是最后的结果，原来输入端不是直接的原始数据，而是在原始数据中提取的特征）</p><p>个人认为这篇文章最大的创新点就是利用注意力机制在一个encoder上得到了两个type（对应与上面提到的自动驾驶的两类任务），然后在两个type后面接不同的解码器做不同的任务。</p><h1 id="cbam">CBAM</h1><p>文章中用到了CBAM模块，首先对它进行一个介绍。</p><p><strong>卷积块注意模块（CBAM）</strong>融合了通道注意力机制和空间注意力机制。采用模块化的设计，几乎可以没有开销地嵌入任何网络。</p><p>总体的结构如下图，它首先做通道注意力，再做空间注意力</p><figure><img src="http://img.meditate.eu.org/note/image-20220810100551027.png" alt="" /><figcaption>卷积块注意模块（CBAM）</figcaption></figure><h2 id="通道注意力模块">通道注意力模块</h2><figure><img src="http://img.meditate.eu.org/note/image-20220810100817512.png" alt="" /><figcaption>通道注意力模块</figcaption></figure><ol type="1"><li>首先在每个通道上做最大池化和平均池化</li><li>分别将两个向量输入一个全连接的网络，输出要与输入向量的长度保持一致</li><li>将两个向量相加，经过Sigmoid函数。得到的向量表示每个通道对应的权重。</li><li>将向量与输入的特征图的每个对应的通道相乘</li></ol><h2 id="空间注意力模块">空间注意力模块</h2><figure><img src="http://img.meditate.eu.org/note/image-20220810101815278.png" alt="" /><figcaption>空间注意力模块</figcaption></figure><ol type="1"><li>沿着通道做最大池化和平均池化。以最大池化为例：就是在所有通道的对应像素点中取一个最大值。得到两个二维的特征图。</li><li>将两个特征图沿着通道拼起来，通过一个卷积层，文章中是7*7的卷积，得到一个<strong>二维</strong>的特征图。</li><li>经过Sigmoid函数，得到的是特征图中每个像素点对应的权重。</li><li>将权重图与输入图中对应位置相乘。</li></ol><h2 id="resnet引入cbam">ResNet引入CBAM</h2><ul><li>CBAM并不会影响原来的网络结构</li><li>CBAM加在残差连接之前</li></ul><figure><img src="http://img.meditate.eu.org/note/image-20220810102431347.png" alt="" /><figcaption>Resnet中加入CBAM</figcaption></figure><h1 id="网络结构">网络结构</h1><figure><img src="http://img.meditate.eu.org/note/image-20220810103009942.png" alt="" /><figcaption>模型结构</figcaption></figure><h2 id="encoder">Encoder</h2><figure><img src="http://img.meditate.eu.org/note/image-20220810123214170.png" alt="" /><figcaption>Encoder的结构</figcaption></figure><p>主干网络采用了ResNet-34，引申出了两种type。type1后续会接上decoder用于处理语义分割，深度预测的任务。type2会去处理信号灯分类和控制预测。作者也对这种操作做了简单的说明，因为语义分割和深度预测往往需要更高分辨率的特征图以免丢失细节，而信号灯分类和控制预测需要隐藏抽象特征。</p><p>注意这里的Conv Block，经过池化以后通道数是不变的，为了能与下一层的特征图相加，接上了一个卷积来使通道数翻倍。</p><h2 id="decoder">Decoder</h2><p>这一部分文章写得有点坑，图中两个decoder的结构参考了一篇论文，然而那篇论文又参考了另一篇论文o(╥﹏╥)o。然而，我读了两篇论文后，发现这里的结构不可能完全与它们一致。所以实际结构怎么样只有看了源码才知道。不过这并不影响理解这部分。</p><p>实际上简单思考也知道，由于==decoder的输出和网络的输入图像是一样大小的==。因此，这里的decoder肯定是用了几个上采样调整到与原图一样的尺寸，最后接上一个softmax。</p><p>作者也说了，经过实验发现，当segmentation的decoder深度大于depth的decoder深度时，模型的整体效果比较好。</p><h2 id="信号灯分类">信号灯分类</h2><p>分为四类：红，黄，绿，无信号灯。对采集到的每一帧都给出一个分类</p><p>应该就是连个全连接层。</p><h2 id="驾驶模块">驾驶模块</h2><p>这里会有两个额外的输入信息，分别是车辆的速度v和更高级别的命令c（如左转）。type2 的特征图展开成一个向量。</p><p>驾驶模块中接了四个不同的头，分别对应于4中不同的高级命令（车道保持，左转，右转，直行）。根据输入的高级命令c，选择不同的头输出操作指令。这种多头的结构要好于单头（之前的论文证明过）。</p><p>==说明：==车辆在面对十字路口中，往往可以有多个指令的选择，这会引起歧义。CIL框架为了解决这个问题会给出一个高级命令（如左转）。然后模型根据这个命令给出更加基础的操作（踩油门，踩刹车，转方向盘）。这个高级指令在这篇文章中是使用A*算法做路径规划给出的。它对没一帧的画面都会给出一个c指示下一步前进的方向。</p><h2 id="损失函数">损失函数</h2><p><span class="math display">\[L_{total}=\lambda _{control}L_{control}+\lambda _{tl}L_{tl}+\lambda _{seg}L_{seg}+\lambda _{dep}L_{dep}\]</span></p><p><span class="math display">\[L_{control}=\sum_{c=1}^3{\gamma _cL_c}\]</span></p><p><span class="math inline">\(L_{control}\)</span>和<span class="math inline">\(L_{dep}\)</span>采用均方差损失，<span class="math inline">\(L_{tl}\)</span>和<span class="math inline">\(L_{seg}\)</span>采用交叉熵损失。</p><p>第二个式子中c=1代表转向，c=2代表油门，c=3代表刹车</p><p><span class="math inline">\(\lambda\)</span>和<span class="math inline">\(\gamma\)</span>凭经验设置。</p><h1 id="实验">实验</h1><h2 id="数据集增强和数据集均衡">数据集增强和数据集均衡</h2><p>为了扩充数据集，作者做了数据集增强。</p><p>采集到的数据集是不平衡的（直线行驶特别多），于是文章采用降采样的方法，让直线行驶选中的概率降低。实测下来数据集均衡对于模型非常重要。</p><p>实验结果看看table就明白了。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2022/06/24/develop/docker/"/>
      <url>/2022/06/24/develop/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="docker">docker</h1><p>英文文档：https://docs.docker.com/</p><p>docker中文文档：https://gitee.com/docker_practice/docker_practice#https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fyeasy%2Fdocker_practice</p><h2 id="一-docker的定义">一 docker的定义</h2><p>docker就是一种容器应用，用于更好地发布应用。docker可以直接装一个个的软件服务。当我们需要安装redis，MySQL时我们需要下载很多的环境，这会非常的繁琐。并且，当我们想将软件给其他人时，往往会出现“这段代码在我的机器上没问题啊”的问题。docker就很好地解决了这个问题，他将你的应用和你的环境做一个打包，就像一个个的集装箱一样，将各个应用进行隔离，这样就可以<strong>运行你的应用而不需要安装环境</strong>了。</p><p>当我们把应用和容器打包到一起时，我们称之为<strong>镜像</strong>。</p><p><strong>更高效的利用系统资源</strong></p><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，<code>Docker</code> 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><p><strong>更快速的启动时间</strong></p><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code> 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><p><strong>一致的运行环境</strong></p><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p><p><strong>持续交付和部署</strong></p><p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps">DevOps (opens new window)</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p><p>使用 <code>Docker</code> 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a href="https://vuepress.mirror.docker-practice.com/image/dockerfile/">Dockerfile</a> 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(Continuous Integration) (opens new window)</a>系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery">持续部署(Continuous Delivery/Deployment) (opens new window)</a>系统进行自动部署。</p><p>而且使用 <a href="https://vuepress.mirror.docker-practice.com/image/build.html"><code>Dockerfile</code></a> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><p><strong>更轻松的迁移</strong></p><p>由于 <code>Docker</code> 确保了执行环境的一致性，使得应用的迁移更加容易。<code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><p><strong>更轻松的维护和扩展</strong></p><p><code>Docker</code> 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&amp;image_filter=official">官方镜像 (opens new window)</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本</p><p><strong>对比传统虚拟机</strong></p><table><thead><tr class="header"><th style="text-align: left;">特性</th><th style="text-align: left;">容器</th><th style="text-align: left;">虚拟机</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">启动</td><td style="text-align: left;">秒级</td><td style="text-align: left;">分钟级</td></tr><tr class="even"><td style="text-align: left;">硬盘使用</td><td style="text-align: left;">一般为 <code>MB</code></td><td style="text-align: left;">一般为 <code>GB</code></td></tr><tr class="odd"><td style="text-align: left;">性能</td><td style="text-align: left;">接近原生</td><td style="text-align: left;">弱于</td></tr><tr class="even"><td style="text-align: left;">系统支持量</td><td style="text-align: left;">单机支持上千个容器</td><td style="text-align: left;">一般几十个</td></tr></tbody></table><h2 id="二-docker安装">二 docker安装</h2><p>https://docs.docker.com/engine/install/centos/#install-using-the-convenience-script</p><p>只有centos7+才能安装docker</p><p>docker安装方式有很多，推荐使用脚本安装。可以在任意Linux系统上安装</p><p>首先下载docker安装的脚本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> -fsSL get.docker.com -o get-docker.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过下载的脚本来下载docker引擎，推荐使用阿里云镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sh</span> get-docker.sh --mirror Aliyun<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动docker服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span> <span class="token comment">#将docker加入开机自启动的列表</span>systemctl start <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>推荐将当前用户加入docker组</p><p>创建docker组</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">groupadd</span> <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将当前用户加入docker组</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">usermod</span> -aG <span class="token function">docker</span> <span class="token environment constant">$USER</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试docker安装是否正确</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> version<span class="token function">docker</span> info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="三-docker的核心概念">三 docker的核心概念</h2><p><strong>镜像 Image</strong></p><p>一个镜像就代表一个软件。</p><p><strong>容器 Container</strong></p><p>一个镜像运行一次就会生成一个容器。容器就是一个运行的软件服务。</p><p>举例：我可以在一台电脑中开多个Chrome浏览器。</p><p><strong>仓库 docker repository</strong></p><p>docker在全球范围内维护了一个镜像仓库。类似于maven</p><p><strong>远程仓库：docker hub</strong></p><p>https://registry.hub.docker.com/_/tomcat?tab=tags</p><p><strong>本地仓库</strong>：用来存储在使用docker过程中的相关镜像</p><h2 id="四-配置阿里云镜像加速">四 配置阿里云镜像加速</h2><p>阿里云会为每个开发者分配一个单独的镜像</p><p>https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> -p /etc/docker<span class="token function">sudo</span> <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'&#123;  "registry-mirrors": ["自己的url"]&#125;EOF</span><span class="token function">sudo</span> systemctl daemon-reload<span class="token function">sudo</span> systemctl restart <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五-镜像操作">五 镜像操作</h2><h3 id="查看本地仓库有那些镜像">1 查看本地仓库有那些镜像</h3><figure><img src="http://img.meditate.eu.org/note/image-20211226161858115.png" alt="" /><figcaption>image-20211226161858115</figcaption></figure><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看本地仓库有那些镜像</span><span class="token function">docker</span> imgae <span class="token function">ls</span>或者<span class="token function">docker</span> images<span class="token comment">#查看指定镜像名</span><span class="token function">docker</span> images 镜像名<span class="token comment">#只列出镜像id</span><span class="token function">docker</span> images -q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>docker可以通过id和名称:版本来查找镜像</p><h3 id="下载镜像">2 下载镜像</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull name:tag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="搜索镜像">3 搜索镜像</h3><p>查看镜像是否存在，不能查看版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> search name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="删除镜像">4 删除镜像</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#正常删除。只能删除没有运行过的镜像</span><span class="token function">docker</span> image <span class="token function">rm</span> 镜像名（name:tag）<span class="token operator">|</span>镜像id<span class="token comment">#强制删除。镜像和容器一起删除</span><span class="token function">docker</span> image <span class="token function">rm</span> -f 镜像名（name:tag）<span class="token operator">|</span>镜像id<span class="token comment">#举例：删除所有Tomcat的镜像</span><span class="token function">docker</span> image <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> images tomcat -q<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="镜像备份和恢复">5 镜像备份和恢复</h3><p>可以将docker打包成一个tar包，方便传输和储存。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#打包镜像</span><span class="token function">docker</span> save 镜像名：版本 -o <span class="token punctuation">(</span>镜像名-版本号<span class="token punctuation">)</span>.tar<span class="token comment">#恢复镜像</span><span class="token function">docker</span> load -i <span class="token punctuation">(</span>tar包的名字<span class="token punctuation">)</span>.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看镜像的构建历史">6 查看镜像的构建历史</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">history</span> 镜像名：版本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="六-容器的操作">六 容器的操作</h2><h3 id="查看正在运行的容器">1 查看正在运行的容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">ps</span><span class="token comment">#查看所有容器，包括停止的</span><span class="token function">docker</span> <span class="token function">ps</span> -a<span class="token comment">#查看所有容器的id</span><span class="token function">docker</span> <span class="token function">ps</span> -aq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行一个容器">2 运行一个容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run name:tag或者<span class="token function">docker</span> run imageid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>container id(容器id)</p><p>imgae(基于哪个镜像)</p><p>command（容器内启动服务的命令）</p><p>names（容器的名称，可以自己指定，不指定则由docker自动分配）</p><figure><img src="http://img.meditate.eu.org/note/image-20211226164719464.png" alt="" /><figcaption>image-20211226164719464</figcaption></figure><h3 id="容器映射">3 容器映射</h3><p>由于docker是操作系统层面的隔离，所以容器有自己的端口。为了在外部访问到容器，要将容器的端口与外部主机的端口相映射。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">8080</span>（宿主机）:8080 tomcat:8.0 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-p可以写多个映射</p><h3 id="后台启动">4 后台启动</h3><p>以守护进程的方式启动。否则每启动一个容器就要重新打开一个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">8080</span>（宿主机）:8080 -d tomcat:8.0 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="给容器取名">5 给容器取名</h3><p>这个name必须是唯一的</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">8080</span>（宿主机）:8080 -d --name tomcat01 tomcat:8.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="停止-重启-启动-暂停-恢复容器">6 停止 重启 启动 暂停 恢复容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#停止</span><span class="token function">docker</span> stop 容器名称<span class="token operator">|</span>容器id<span class="token comment">#重启</span><span class="token function">docker</span> restart 容器名称<span class="token operator">|</span>容器id<span class="token comment">#启动</span><span class="token function">docker</span> start 容器名称<span class="token operator">|</span>容器id<span class="token comment">#暂停</span><span class="token function">docker</span> pause 容器名称<span class="token operator">|</span>容器id<span class="token comment">#恢复</span><span class="token function">docker</span> unpause 容器名称<span class="token operator">|</span>容器id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="杀死容器">7 杀死容器</h3><p>与stop不同，kill容器容器中不会进行后续操作，属于强制停止。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">kill</span> 容器名称<span class="token operator">|</span>容器id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="删除容器">8 删除容器</h3><p>删除容器不会影响到镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#不在运行的容器</span><span class="token function">docker</span> <span class="token function">rm</span> 容器名称<span class="token operator">|</span>容器id<span class="token comment">#强制删除容器</span><span class="token function">docker</span> <span class="token function">rm</span> -f 容器名称<span class="token operator">|</span>容器id<span class="token comment">#删除所有容器</span><span class="token function">docker</span> <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> -aq<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看容器日志">9 查看容器日志</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> logs 容器名称<span class="token operator">|</span>容器id<span class="token comment">#查看实时的日志</span><span class="token function">docker</span> logs -f 容器名称<span class="token operator">|</span>容器id<span class="token comment">#加上宿主机中的时间</span><span class="token function">docker</span> logs -t 容器名称<span class="token operator">|</span>容器id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="进入容器的内部">10 进入容器的内部</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it 容器名称<span class="token operator">|</span>容器id <span class="token function">bash</span><span class="token comment">#-it 代表以交互模式进入</span><span class="token comment">#与容器中的bash交互</span><span class="token comment">#退出容器</span><span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="容器与宿主机之间的文件传输">11 容器与宿主机之间的文件传输</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#将容器中的文件或目录拷贝到宿主机</span><span class="token function">docker</span> <span class="token function">cp</span> 容器名称<span class="token operator">|</span>容器id:文件或目录 宿主机中的目录<span class="token comment">#将宿主机上的文件或目录拷贝到容器中</span><span class="token function">docker</span> <span class="token function">cp</span> 宿主机中的目录或文件 容器名称<span class="token operator">|</span>容器id:容器的目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看容器内运行的进程">12 查看容器内运行的进程</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">top</span> 容器名称<span class="token operator">|</span>容器id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看容器内细节指令">13 查看容器内细节指令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> inspect 容器名称<span class="token operator">|</span>容器id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="容器的数据卷机制">14 容器的数据卷机制</h3><p>data volume：用来实现容器中数据和宿主机中的数据进行映射。通俗来说就是设置一块空间与容器中的目录和宿主机中的目录进行映射。这样容器空间与宿主机的目录就实现了双向绑定。随便更改哪边另一边都会更改。</p><h4 id="数据卷挂载">14.1 数据卷挂载</h4><p><strong>数据卷只能在容器首次启动时设置</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#使用绝对路径设置数据卷（可以多个）</span><span class="token function">docker</span> run -v 宿主机绝对路径:容器内路径<span class="token comment">#注意：这种方式启动时会将容器路径的内容全部清空</span><span class="token function">docker</span> run -v 宿主机绝对路径:容器内路径:ro<span class="token comment">#设置ro时表示容器内的目录是只读的。只能通过宿主机操作。</span><span class="token comment">#使用别名方式设置数据卷</span><span class="token function">docker</span> run -v 别名:容器内路径<span class="token comment">#例如</span><span class="token function">docker</span> run -v aa:/usr/local/tomcat/webapps<span class="token comment">#aa代表docker数据卷中的别名，aa不存在会自动创建，存在则直接使用</span><span class="token comment">#使用别名方式会保留容器路径原始内容，前提是别名对应的路径不存在内容</span><span class="token comment"># 别名挂载还有一种匿名挂载</span><span class="token function">docker</span> run -d  -v 容器内目录  镜像名/id  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>docker根据别名创建的目录一般在/var/lib/docker/volume</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看所有挂载的卷</span><span class="token function">docker</span> volume <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="数据卷容器">14.2 数据卷容器</h4><p>一个容器可以通过<code>volumes from</code>直接使用其他容器的数据卷挂载方式。并且这样指定后，多个容器是共享数据卷的，共享的数据卷只要还有容器使用它就不会消失。可以通过这种 机制来实现配合文件的共享或者数据库的数据同步等操作。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it --name container02 --volumes from container01 镜像名/id  <span class="token comment"># 将两个容器进行挂载</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="将容器打包成一个镜像">15 将容器打包成一个镜像</h3><p>将自己的容器打包成一个镜像，这样以后只需要运行相应的镜像就行了</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> commit -m <span class="token string">"描述信息"</span> -a <span class="token string">"作者"</span> 容器名称<span class="token operator">|</span>容器id 镜像名：版本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看容器或者镜像的信息">16 查看容器或者镜像的信息</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> inspect 镜像<span class="token operator">|</span>容器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="七-镜像构成原理">七 镜像构成原理</h2><p><strong>自己打包的镜像为什么那么大？</strong></p><p>因为容器是一种轻量级的，可执行的独立软件包，它包含了软件运行的库。</p><p><strong>为什么从官方下载的镜像那么小？</strong></p><p>因为docker使用了联合文件系统。每个镜像存在一个base镜像，这样就实现了底层镜像的复用，不用存储每个重复的运行依赖。因此，当我们下载Tomcat8.0时，会发现我们要下载许多东西，当我们下载Tomcat8.1时会发现下载的东西变少了。</p><p>每个镜像都由很多层次构成，Docker 使用 <a href="https://en.wikipedia.org/wiki/UnionFS">Union FS (opens new window)</a>将这些不同的层结合到一个镜像中去。</p><p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。</p><p>Docker 在 OverlayFS 上构建的容器也是利用了类似的原理。</p><h2 id="八-dockerfile">八 dockerFile</h2><h3 id="概念">1 概念</h3><p>dockerfile是用来构建docker镜像的文件，是一个<strong>命令参数脚本</strong>。</p><p>官方镜像的很多都是基础包，我们通常会构建自己的镜像。</p><p>构建步骤：</p><ol type="1"><li>编写一个dockerfile文件</li><li>docker build为一个镜像</li><li>docker run运行镜像</li><li>docker push发布镜像</li></ol><h3 id="指令">2 指令</h3><table><thead><tr class="header"><th style="text-align: center;">命令</th><th style="text-align: center;">效果</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">FROM</td><td style="text-align: center;">基础镜像：Centos/Ubuntu</td></tr><tr class="even"><td style="text-align: center;">MAINTAINER</td><td style="text-align: center;">镜像作者+邮箱</td></tr><tr class="odd"><td style="text-align: center;">RUN</td><td style="text-align: center;">镜像构建的时候需要运行的命令</td></tr><tr class="even"><td style="text-align: center;">ADD</td><td style="text-align: center;">为镜像添加内容（压缩包）</td></tr><tr class="odd"><td style="text-align: center;">WORKDIR</td><td style="text-align: center;">镜像工作目录（进入容器时的目录）</td></tr><tr class="even"><td style="text-align: center;">VOLUME</td><td style="text-align: center;">挂载的目录</td></tr><tr class="odd"><td style="text-align: center;">EXPOSE</td><td style="text-align: center;">暴露端口配置</td></tr><tr class="even"><td style="text-align: center;">CMD/ENTRYPOINT</td><td style="text-align: center;">指定这个容器启动时要运行的命令（CMD替代先前命令，ENTRYPOINT在先前命令后追加）</td></tr><tr class="odd"><td style="text-align: center;">COPY</td><td style="text-align: center;">类似于ADD，将文件拷贝到镜像中</td></tr><tr class="even"><td style="text-align: center;">ENV</td><td style="text-align: center;">构建时设置环境变量</td></tr></tbody></table><h3 id="构建自己的centos">3 构建自己的CentOS</h3><p>下载CentOS基础镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull centos:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建dockerfile文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> mydockerfile-centos<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>写dockerfile文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#选择基础镜像。centos8 21年的时候停止了源服务，因此yum命令会报错。这里直接指定7版本</span>FROM centos:7<span class="token comment">#作者信息</span>MAINTAINER qjk<span class="token operator">&lt;</span><span class="token number">1256929691</span>@qq.com<span class="token operator">></span><span class="token comment">#环境变量</span>ENV MYPATH /usr/local<span class="token comment">#进入容器时的目录</span>WORKDIR <span class="token variable">$MYPATH</span><span class="token comment">#需要运行的命令</span>RUN yum -y <span class="token function">install</span> <span class="token function">vim</span>RUN yum -y <span class="token function">install</span> net-tools<span class="token comment">#暴露端口</span>EXPOSE <span class="token number">8888</span><span class="token comment">#输出一些信息</span>CMD <span class="token builtin class-name">echo</span> <span class="token variable">$MYPATH</span>CMD <span class="token builtin class-name">echo</span> <span class="token string">"---end---"</span><span class="token comment">#运行bash</span>CMD /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构建镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#-f 使用的dockerfile文件 -t 镜像名:版本号 . 当前上下文环境</span><span class="token function">docker</span> build -f mydockerfile-centos -t mycentos:1.0 <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it mycentos:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试发现安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@d92186b194dc local<span class="token punctuation">]</span><span class="token comment"># ifconfig </span>eth0: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">416</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu <span class="token number">1500</span>        inet <span class="token number">172.17</span>.0.2  netmask <span class="token number">255.255</span>.0.0  broadcast <span class="token number">172.17</span>.255.255        ether 02:42:ac:11:00:02  txqueuelen <span class="token number">0</span>  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets <span class="token number">8</span>  bytes <span class="token number">656</span> <span class="token punctuation">(</span><span class="token number">656.0</span> B<span class="token punctuation">)</span>        RX errors <span class="token number">0</span>  dropped <span class="token number">0</span>  overruns <span class="token number">0</span>  frame <span class="token number">0</span>        TX packets <span class="token number">0</span>  bytes <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span> B<span class="token punctuation">)</span>        TX errors <span class="token number">0</span>  dropped <span class="token number">0</span> overruns <span class="token number">0</span>  carrier <span class="token number">0</span>  collisions <span class="token number">0</span>lo: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">7</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,LOOPBACK,RUNNING<span class="token operator">></span>  mtu <span class="token number">65536</span>        inet <span class="token number">127.0</span>.0.1  netmask <span class="token number">255.0</span>.0.0        loop  txqueuelen <span class="token number">1000</span>  <span class="token punctuation">(</span>Local Loopback<span class="token punctuation">)</span>        RX packets <span class="token number">0</span>  bytes <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span> B<span class="token punctuation">)</span>        RX errors <span class="token number">0</span>  dropped <span class="token number">0</span>  overruns <span class="token number">0</span>  frame <span class="token number">0</span>        TX packets <span class="token number">0</span>  bytes <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span> B<span class="token punctuation">)</span>        TX errors <span class="token number">0</span>  dropped <span class="token number">0</span> overruns <span class="token number">0</span>  carrier <span class="token number">0</span>  collisions <span class="token number">0</span><span class="token punctuation">[</span>root@localhost data<span class="token punctuation">]</span><span class="token comment"># docker history mycentos:1.0</span>IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT68ec40605859   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  CMD ["/bin/sh" "-c" "/bin…   0B        </span>a611dbac6ce6   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  CMD ["/bin/sh" "-c" "echo…   0B        </span>3760049dc190   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  CMD ["/bin/sh" "-c" "echo…   0B        </span>8a9d3aecc1fb   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  EXPOSE 8888                  0B        </span>ba8c71fa6dde   <span class="token number">21</span> minutes ago   /bin/sh -c yum -y <span class="token function">install</span> net-tools             171MB     1de039243935   <span class="token number">21</span> minutes ago   /bin/sh -c yum -y <span class="token function">install</span> <span class="token function">vim</span>                   226MB     7f9dde17bf22   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop) WORKDIR /usr/local            0B        </span>97ada81ddf08   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  ENV MYPATH=/usr/local        0B        </span>53e586d5ba0a   <span class="token number">22</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  MAINTAINER qjk&lt;1256929691…   0B        </span>eeb6ee3f44bd   <span class="token number">9</span> months ago     /bin/sh -c <span class="token comment">#(nop)  CMD ["/bin/bash"]            0B        </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">9</span> months ago     /bin/sh -c <span class="token comment">#(nop)  LABEL org.label-schema.sc…   0B        </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">9</span> months ago     /bin/sh -c <span class="token comment">#(nop) ADD file:b3ebbe8bd304723d4…   204MB     </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="cmd和entrypoint的区别">4 CMD和ENTRYPOINT的区别</h3><p>例如dockerfile中使用CMD命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">CMD <span class="token punctuation">[</span><span class="token string">"ls"</span>,<span class="token string">"-a"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>后续启动容器时想要执行<code>ls -l</code>命令，这样写会报错</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it mycentos:1.0 -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为<code>-l</code>会直接替换ls -a，正确的写法是这样</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it mycentos:1.0 <span class="token function">ls</span> -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如dockerfile中使用ENTRYPOINT命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"ls"</span>,<span class="token string">"-a"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样写就不会报错</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it mycentos:1.0 -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="构建tomcat">5 构建Tomcat</h3><p>Dockerfile文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FROM centos  COPY readme.md /usr/local/readme.md<span class="token comment">#添加压缩包，docker会自动解压</span>ADD jdk8.tar.gz /usr/localADD tomcat.tar.gz /usr/localRUN yum -y <span class="token function">install</span> <span class="token function">vim</span>ENV MYPATH /usr/localWORKDIR <span class="token variable">$MYPATH</span>ENV JAVA_HOME /usr/local/jdk1.8.0_141ENV CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jarENV <span class="token environment constant">PATH</span> <span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$JAVA_HOME</span>/binEXPOSE <span class="token number">8080</span><span class="token comment">#命令可以用&amp;&amp;直接拼接</span>CMD /usr/local/apache-tomcat-10.0.12/bin/startup.sh <span class="token operator">&amp;&amp;</span> <span class="token function">tail</span> -F /usr/local/apache-tomcat-10.0.12/bin/logs/catalina.out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="发布镜像">6 发布镜像</h3><blockquote><p>dockerhub</p></blockquote><ol type="1"><li>注册dockerhub账号</li><li>登录dockerhub</li><li>发布</li></ol><p>登录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> login -u 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过<code>tag</code>创建版本号</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> tag 镜像名<span class="token operator">|</span><span class="token function">id</span> 新的镜像名:版本号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发布</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> push 镜像名:版本号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="九-docker网络">九 Docker网络</h2><h3 id="docker0">1 Docker0</h3><p>通过命令<strong>ip addr</strong>查看本地ip地址，我们发现除了本机回环地址和埃里远的内网地址外，还多了一个网卡：Docker0，这是Docker服务启动后自动生成的。</p><p>而如果进入一个正在后台运行的tomcat容器，同样使用<strong>ip addr</strong>命令，发现容器得到了一个新的网络：<strong>12: eth@if13</strong>，ip地址：<strong>172.17.0.2</strong>。这是Docker在容器启动时为其分配的。</p><p>docker容器的网络是通过<code>veth</code>（Linux提供的虚拟网卡接口）来管理的。宿主机和容器分别连接到一个虚拟网卡接口。例如：宿主机一个新网络<strong>13: vethda1df4b@if12</strong>，对应容器内网络地址的<strong>12: eth@if13</strong>。12和13分别是宿主机端和容器端的接口编号。宿主机和容器之间可以ping通，容器与容器间也可以ping通，会通过docker0转发，docker0类似于局域网中的路由器。</p><figure><img src="http://img.meditate.eu.org/note/image-20220624095350600.png" alt="" /><figcaption>image-20220624095350600</figcaption></figure><p>容器一删除，对应的网桥也会随之删除。</p><h3 id="link">2 --link</h3><blockquote><p>若编写一个微服务并连接数据库，如果数据库ip改变，如何根据容器名而不是ip访问容器？显然，直接使用容器名是无法ping通容器内部的：</p></blockquote><p>这时我们可以在容器启动命令中加入一个选项：<strong>–link</strong>，使得我们可以根据容器名来访问容器。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d -P --link 容器名/id 镜像名/id<span class="token comment">#例如:启动一个容器并与tomcat01进行相连</span><span class="token function">docker</span> run -d -P --link tomcat01 --name tomcat02 tomcat:8 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>连接后，tomcat02可以直接ping tomcat01，而<strong>tomcat01却不能ping通tomcat02</strong>。</p><p>实现原理：在tomcat02的host文件中添加了tomcat01的ip地址。</p><p>显然这种方式过于低级，无法解决上述问题，因此--link不建议使用。</p><p>在实际开发中，docker0网卡的局限性过大，不支持服务名访问，因此往往会使用自己的网卡代替docker0。</p><h3 id="自定义网络">3 自定义网络</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看所有的docker网络</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker network ls</span>NETWORK ID     NAME      DRIVER    SCOPE8d9e97cd0f61   bridge    bridge    <span class="token builtin class-name">local</span>7d43eef7b13e   <span class="token function">host</span>      <span class="token function">host</span>      <span class="token builtin class-name">local</span>bc1e545c960e   none      null      <span class="token builtin class-name">local</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>docker中的网络模式有：</p><ul><li>bridge：桥接（docker默认）/</li><li>none：不配置网络 /</li><li>host：和宿主机共享网络</li></ul><p><code>docker run</code>命令默认带有一个参数–net bridge，此处的bridge指的就是docker0。可以自己手动创建一个新的网络。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span>  network create --driver 网络模式 --subnet 子网ip --gateway 网关 网络名     <span class="token comment">#例如</span><span class="token function">docker</span>  network create --driver bridge --subnet <span class="token number">192.168</span>.1.0/16 --gateway <span class="token number">192.168</span>.1.1 mynet     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>创建容器并使用自己创建的网络。这样创建的容器可以通过ping容器名直接ping通。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d --name tomcat01 -net mynet tomcat:8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="网络连通">4 网络连通</h3><p>对于建立在不同网络下(docker0, newnet)的两个容器tomcat01和tomcat02，他们的网段不同，因此是无法彼此ping通容器内部的：</p><p>这时我们需要通过docker network connect命令打通容器与网络之间的连接：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> network connect 网络名 容器名/id例如：<span class="token function">docker</span> network connect mynet tomcat01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十-springboot微服务打包成镜像">十 springboot微服务打包成镜像</h2><p>打包成jar包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mvn package<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编写Dockerfile</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FROM java:8COPY *.jar /app.jarCMD <span class="token punctuation">[</span><span class="token string">"--server.port=8080"</span><span class="token punctuation">]</span>EXPOSE <span class="token number">8080</span>ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"java"</span>,<span class="token string">"-jar"</span>,<span class="token string">"app.jar"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构建镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1.复制jar和DockerFIle到服务器</span><span class="token comment"># 2.构建镜像</span><span class="token function">docker</span> build -t xxxxx:xx  <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>壁纸</title>
      <link href="/2022/06/10/resource/bi-zhi/"/>
      <url>/2022/06/10/resource/bi-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="壁纸网站推荐">壁纸网站推荐</h1><h2 id="极简壁纸">极简壁纸</h2><p>https://bz.zzzmh.cn/index</p><p>一个中文的壁纸网站，壁纸质量很高，分类不太方便，适合桌面端。</p><h2 id="anime-pictures">anime-pictures</h2><p>https://anime-pictures.net/pictures/view_posts/0?lang=zh_CN</p><p>一个插画分享网站，全世界的画师可以在这个网站分享作品。主要以动漫人物为主。</p><h2 id="wallhaven">wallhaven</h2><p>https://wallhaven.cc/</p><p>最强大的壁纸网站，分类功能完善，壁纸种类弃齐全。</p><h2 id="wallpaperscraft">wallpaperscraft</h2><p>https://wallpaperscraft.com/</p><p>壁纸种类多，但是质量不怎么样。可以自定义壁纸的尺寸。</p><h2 id="wallpaperhub">wallpaperhub</h2><p>https://wallpaperhub.app/</p><p>主要是收集了一些产品的官方壁纸，比如Windows11，surface等。</p><h2 id="wallpaper-abyss">wallpaper abyss</h2><p>https://wall.alphacoders.com/</p><p>可以选择简体中文。搜索功能强大，输入关键词后可以很快找到想要的壁纸，壁纸也非常多。</p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 壁纸 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
