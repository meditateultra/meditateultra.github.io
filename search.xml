<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>既然有HTTP协议，为什么还要有RPC</title>
      <link href="/2022/09/26/network/ji-ran-you-http-xie-yi-wei-shi-me-huan-yao-you-rpc/"/>
      <url>/2022/09/26/network/ji-ran-you-http-xie-yi-wei-shi-me-huan-yao-you-rpc/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/DuOI-KZ-YnNwBpZoU_881w">https://mp.weixin.qq.com/s/DuOI-KZ-YnNwBpZoU_881w</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Dynamic Weights in Multi-Objective Deep Reinforcement Learning</title>
      <link href="/2022/09/22/ml/lun-wen-yue-du-dynamic-weights-in-multi-objective-deep-reinforcement-learning/"/>
      <url>/2022/09/22/ml/lun-wen-yue-du-dynamic-weights-in-multi-objective-deep-reinforcement-learning/</url>
      
        <content type="html"><![CDATA[<p>本文研究了权重变化的多目标强化学习方式。</p><p>==主要贡献：==</p><ol type="1"><li>提出了一种能够适应动态权重变化的多目标Q-Learning方式（<strong>CN</strong>）。</li><li>提出了多样化经验化回放缓存（<strong>DER</strong>）保存多样化的经验，使模型能够从过去的不同的权重的经验中获取对当前权重设置有益的经验，实验证明DER对于动态权重变化的强化学习方式提升很大。</li><li>为多目标强化学习提出了一个新的benchmark-矿车（<strong>Minecart</strong>）。</li></ol><p>这篇文章的多目标采用线性标量函数的方式实现。</p><h1 id="conditioned-networkcn">Conditioned Network（CN）</h1><h2 id="cn的模型结构">CN的模型结构</h2><figure><img src="http://img.meditate.eu.org/note/image-20220922103848512.png" alt="" /><figcaption>CN的模型结构</figcaption></figure><p>采用的Dueling Q Network（具体见蘑菇书），输入有两个值：</p><p>state：由于CN是端到端的，输入的是一张图像，经过特征提取后变成一个state向量输入。</p><p>weight：各个目标的权重向量</p><h2 id="训练过程">训练过程</h2><p>我们希望CN能够适应动态的权重变化，所以在一味地在当前的权重向量（active weight vector）上训练是不行的。我们希望CN在拟合当前weight的基础上不遗忘过去的weight。所以样本一次应该在多个权重向量上进行训练。</p><p>文章中的做法就是在当前的权重向量<span class="math inline">\(w_t\)</span>和一个随机的先前遇到的权重向量<span class="math inline">\(w_j\)</span>上平均地求损失。<span class="math inline">\(Q_{CN}^{-}\)</span>是target net，CN采用Double Q-Learning的方式。 <span class="math display">\[\begin{aligned}&amp;\frac{1}{2}\left[\left|\mathbf{y}_{\mathbf{w}_t}^{(j)}-\mathbf{Q}_{C N}\left(a_j, s_j ; \mathbf{w}_t\right)\right|+\left|\mathbf{y}_{\mathbf{w}_j}^{(j)}-\mathbf{Q}_{C N}\left(a_j, s_j ; \mathbf{w}_j\right)\right|\right] \\&amp;\mathbf{y}_{\mathbf{w}}^{(j)}=\mathbf{r}_j+\gamma \mathbf{Q}_{C N}^{-}\left(\underset{a \in A}{\operatorname{argmax}} \mathbf{Q}_{C N}\left(a, s_{j+1} ; \mathbf{w}\right) \cdot \mathbf{w}, s_{j+1} ; \mathbf{w}\right)\end{aligned}\]</span></p><h2 id="算法步骤">算法步骤</h2><figure><img src="http://img.meditate.eu.org/note/image-20220922110239464.png" alt="" /><figcaption>CN算法步骤</figcaption></figure><p>整体就是一个典型的Q-Learning过程，这里要维护两个Buffer，<span class="math inline">\(W\)</span>存储过去的权重向量 ，<span class="math inline">\(D\)</span>存储经验。</p><p><span class="math inline">\(getWeightVector()\)</span>这个函数用来获取active weight即<span class="math inline">\(w_t\)</span>，在后续实验中提到了两种不一样的生成方式。</p><h1 id="diverse-experience-replayder">Diverse Experience Replay（DER）</h1><h2 id="动机">动机</h2><p>以前的Q-Learning包括上面的CN都是选择维护了一个先进先出的缓存，粗暴地存储了最近的以往的经验。但是文章中说了，<strong>一个以往的weight的经验可能对于当前的weight的训练是有害的。</strong>==我们希望在缓存中保存那些对于当前weight训练有益的经验（有益的经验就是指与当前weight尽可能相关的经验）。==因为weight变化是随机的，那么在我们不知道未来会采用什么样的weight前提下，==我们希望使缓冲区中经验尽可能的多样化（diverse）。==这样在当前weight（active weight）训练时随机选就有可能选到对自己训练有益的经验。</p><p>比较容易想到的就是增大缓冲区，但是这是不可行的。文章列出了两点理由：</p><ol type="1"><li>除非回放缓冲区是无限的，否则在到达需要它们的权重空间区域之前，仍然需要擦除旧的经验。</li><li>即使这些相关经验仍然存在，由于总数过多，我们比较难以选到这些经验。</li></ol><p>所以文章提出了DER。</p><h2 id="der">DER</h2><p>DER将<strong>trajectory</strong>（一段完整的状态-动作序列）作为原子单位处理，这样做是为了便于获取从终止状态到初始状态间的完整的Q值。</p><p>使用签名函数<span class="math inline">\(s\)</span>为每个trajectory计算一个签名（signature），当考虑将trajectory添加入Buffer时，多样性函数<span class="math inline">\(d\)</span>根据签名计算每个trajectory的与buffer中其他trajectory的相对多样性。如果新trajectory的加入增加了缓冲区的整体多样性，则仅将新trajectory添加到多样化缓冲区中。当它已满时，对多样性贡献最小的trajectory将从多样性缓冲区中弹出。</p><h2 id="在动态权重中使用der">在动态权重中使用DER</h2><ol type="1"><li>每个回合的转换被视作一条trajectory</li><li>签名函数<span class="math inline">\(s\left( \tau \right) =\sum_{t=0}^{\left| \tau \right|}{\gamma ^tr_t}\)</span></li><li>使用crowding distance算法作为多样性度量（算法没去看）</li></ol><p>在动态权重中，也保留了一个FIFO的buffer，只有当FIFO buffer满了时才会将最老的trajectory尝试加入DER。</p><p>在训练时会现在DER中采样训练，然后在FIFO buffer中进一步训练。</p><h1 id="新的benchmark-minecart">新的Benchmark-Minecart</h1><p>简略写一下，详见论文。</p><figure><img src="http://img.meditate.eu.org/note/image-20220922143111247.png" alt="" /><figcaption>Minecraft的表述图</figcaption></figure><p>b代表矿车，c~g代表不同的矿坑，每回合里面会随机生成不同的矿石。a代表矿石出售点。</p><p>reward vector包含<span class="math inline">\(N\)</span>维前<span class="math inline">\(N-1\)</span>维代表矿石的数量，第<span class="math inline">\(N\)</span>维代表燃料消耗。</p><h1 id="以往的算法用在动态权重下">以往的算法用在动态权重下</h1><p>为了实验中方便比较以往的多目标算法，文章还调整传统的MORL以适应动态权重。</p><h2 id="uvfa">UVFA</h2><p>没看过这个算法，先pass</p><h2 id="multi-networkmn">Multi-Network（MN）</h2><p>实际上这种方式非常的暴力，就是将传统的标量化DQN在多个不同的weight上训练，将不同weight下的最优策略存储进一个Buffer中<span class="math inline">\(\Pi\)</span>。这里的<span class="math inline">\(\Pi\)</span>不会太大，因为它是CSS的子集（CSS就是在任意weight下最优策略的集合）。而CSS不会太大。这一点在Minecraft中有说明过，下图的一个区域代表这一区域中最优策略是一致的。实际上也就是只有7块。</p><figure><img src="http://img.meditate.eu.org/note/image-20220922152430758.png" alt="" /><figcaption>Minecraft下不同weight的最优策略区域</figcaption></figure><p><strong>替换规则：</strong></p><p>对于当前的<span class="math inline">\(w\)</span>训练得到一个最优的<span class="math inline">\(\pi_w\)</span>，如果<span class="math inline">\(V^{\pi_w}\)</span>对于至少一个过去的权重向量或当前的权重向量 w 改进了<span class="math inline">\(\Pi\)</span>中的策略的最大标量值，则将其保存。数学语言表示更加清晰： <span class="math display">\[\exists w\in W,\ V^{\pi _t}\cdot w&gt;\max _{V&#39;\in \Pi}V&#39;\cdot w-\kappa\]</span> 其中，<span class="math inline">\(\kappa\)</span>是一个常数，是为了解决近似误差问题。当两个标量化值在彼此的误差 κ 内时，较新的策略更受青睐。</p><p>此时，将<span class="math inline">\(\pi_w\)</span>加入<span class="math inline">\(\Pi\)</span>。所有被 <span class="math inline">\(\pi_w\)</span> 冗余的旧策略都从<span class="math inline">\(\Pi\)</span>中删除。如果<span class="math inline">\(\pi_w\)</span>对于任何遇到的权重向量都不是最佳策略，那么它自己就是冗余的。</p><p><strong>训练新的weight：</strong></p><p>当训练一个新<span class="math inline">\(w\)</span>时，会从<span class="math inline">\(\Pi\)</span>中选一个<span class="math inline">\(\pi&#39;\)</span>使得<span class="math inline">\(V^{\pi&#39;}\cdot\pi&#39;\)</span>最大。在<span class="math inline">\(\pi&#39;\)</span>的基础上训练，这样训练起来比较快。</p><p>MN有一个很大的缺点，因为MN 基于预测的 Q 值比较策略，所以不准确的输出会通过使 MN 偏向于高估的策略来干扰训练。因此，MN 需要对每个权重向量进行长时间的训练才能获得准确的值进行比较。==可想而知MN是比较慢的。==</p><h1 id="实验">实验</h1><p><strong>评判指标：</strong></p><p>最优策略的价值与实际reward之间的差值：<span class="math inline">\(\varDelta= V_{w}^*\cdot w-\sum_{t=0}^T{\gamma^{t}r_t\cdot w}\)</span>，<span class="math inline">\(V_w^*\)</span>代表<span class="math inline">\(w\)</span>下的最优策略的value。<span class="math inline">\(\varDelta\)</span>显然是越小越好。</p><p>文章讨论了两种不同的<span class="math inline">\(w\)</span>的生成方式：</p><ol type="1"><li>稀疏情况：从Dirichlet分布 (<span class="math inline">\(\alpha=1\)</span>) 中随机采样的，对于Minecart，每 50k步采样一次，对于 DST，每 5k步采样一次。</li><li>固定的变化：<span class="math inline">\(w\)</span>在10个回合内线性地变化到<span class="math inline">\(w&#39;\)</span></li></ol><figure><img src="http://img.meditate.eu.org/note/image-20220922154243467.png" alt="" /><figcaption>在Minecraft上的实验结果</figcaption></figure><p>MO：单个多目标 DQN 通过标量化Q-Learning仅在当前 w 上持续训练（不维护多个网络）。</p><p>CN：CN与UVFA相结合</p><p>CN-ACTIVE：CN仅在当前的w上训练。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多目标强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据中心网络综述</title>
      <link href="/2022/09/20/ml/shu-ju-zhong-xin-wang-luo-zong-shu/"/>
      <url>/2022/09/20/ml/shu-ju-zhong-xin-wang-luo-zong-shu/</url>
      
        <content type="html"><![CDATA[<p>目前常用的数据中心网络拓扑是多根树架构。该拓扑分为三层，从下到上分别为==接入层、汇聚层和核心层==，规模较小的数据中心可以只有接入层和汇聚层。接入层交换机将服务器连接起来。为了提高可用性，一台服务器可能连接到两台接入交换机。同样，接入交换机一般连接到两台汇聚层交换机。最后，汇聚交换机同时连接到多台核心层交换机。绝大部分数据中心网络通常会有一定的带宽收敛比(Oversubscription)。所谓带宽收敛比，是指在最坏情况下服务器两两之间通信需要的最大带宽和数据中心网络拓扑可以提供的带宽的比值。带宽收敛比为1：1表示所有的服务器都能以其网卡速率进行两两之间通信。通常，为了降低成本，数据中心网络都会有收敛比，一般为2.5：1到8：1。</p><figure><img src="http://img.meditate.eu.org/note/image-20220917232623597.png" alt="" /><figcaption>数据中心网络常用拓扑图</figcaption></figure><h1 id="数据中心的定义">数据中心的定义</h1><p>随着数据中心的发展，尤其是云计算技术的出现，数据中心已经不只是一个简单的服务器统一托管、维护的场所，它已经衍变成一个集大数据量运算和存储为一体的高性能计算机的集中地。各T厂商将之前以单台为单位的服务器通过各种方式变成多台为群体的模式，在此基础上开发诸如虚拟化、云计算、云存储等一系列的功能，以提高单位数量内服务器的使用效率。目前，新一代数据中心(又称云计算数据中心、集装箱式数据中心或者绿色数据中心)的概念仍没有个标准定义。普遍认为新一代数据中心（朱伟雄，2009）是：基于标准构建模块，通过模块化软件实现自动化7×24小时无人值守计算与管理，并以供应链方式提供共享的基础设施、信息与应用等T服务。</p><h1 id="数据中心网络的研究问题">数据中心网络的研究问题</h1><ul><li><p>DCN的架构及其拓扑</p></li><li><p>能源效率问题。如何保持 DCN 功率预算可管理，包括虚拟化、网络负载管理和调度</p></li><li><p>DCN 中的拥塞处理，包括拥塞通知和避免</p></li><li><p>DCN 中的路由，并提供高效且具有成本效益的路由机制</p></li></ul><p>······</p><p>去了解了一下数据中心和数据中心网络，了解了几个基本的网络架构。感觉数据中心和数据中心网络中可以研究的问题很多，但是适合用AI做的并不是很多。我主要总结了几个。</p><h1 id="适合用ai做的问题">适合用AI做的问题</h1><h2 id="负载平衡">负载平衡</h2><p>负载平衡实际上就是选择路径并调度流的过程，可以用AI来调度各条路上的流，以一些指标为目标，比如吞吐量和延迟等。</p><h3 id="负载平衡的定义">负载平衡的定义</h3><p><strong>负载平衡相当于最小化链路的最大利用率。</strong><span class="math inline">\(s,d\)</span>代表了流的起点和终点，<span class="math inline">\(u,v\)</span>代表了以<span class="math inline">\(s,d\)</span>为起点终点的图中某条边的两个交换机。<span class="math inline">\(c_{u,v}\)</span>代表了链路的最大容量。 <span class="math display">\[min\,\,max_{u,v\in E}\frac{\sum_{s,d}{f_{u,v}^{s,d}}}{c_{u,v}}\]</span></p><h3 id="负载平衡的目标">负载平衡的目标</h3><p>由于数据中心中的应用程序有其特定的需求，负载平衡算法应考虑到这一点，有时需要在不同需求之间进行权衡。负载平衡算法的四个主要目标：==高性能、可扩展性、鲁棒性和能量效率。==这是主要的目标，实际上还会有其他目标。比如各个包的到达的最晚时间。</p><ul><li>高性能：负载均衡算法需要根据应用需求考虑的两个主要需求吞吐量和延迟。</li><li>可扩展性：（1）负载均衡算法是否适用大规模的数据中心网络，并且部署成本是不是高；（2）负载均衡算法是否适用不同的拓扑结构和运行不同应用程序的数据中心环境</li><li>鲁棒性：负载平衡算法如何应对数据中心的故障和拓扑变化是一个关键问题。</li><li>能量效率：负载平衡算法必须考虑能量消耗，并满足用最小设备子集来满足应用要求</li></ul><h3 id="负载平衡算法的两个过程">负载平衡算法的两个过程</h3><p>数据中心网络负载平衡机制的设计分解为两个主要过程：==收集拥塞信息和选择路径。==负载平衡机制的一个关键过程是选择一个或多个适当的度量来表示拥塞，并将拥塞信息传输给将做出负载平衡决策的实体。在获得数据中心网络的拥塞信息后，负载平衡方案需要调度不同路径上的到达流以平衡负载。</p><h2 id="服务器负载平衡">服务器负载平衡</h2><p>服务器负载平衡机制旨在平衡服务器之间的流量。根据服务器的负载和应用程序的需求将请求分发到不同的服务器。这就涉及到服务器的选择调度问题。</p><h2 id="虚拟化">虚拟化</h2><p>虚拟化技术用于虚拟化物理机并为多个用户提供虚拟机。因此，提供商可以建立云数据中心，在相同硬件资源的基础上为多个用户提供服务。具体来说，每个租户都有一个拥有客户资源的私有网络，物理链路的带宽根据租户的需求进行分配。</p><p>这也带来了物理链路带宽分配的问题，而且可能是同一条物理链路的分配问题。比如不同用户的优先级可能不同，由于不同的租户支付不同的钱，他们的优先级也不同。一般来说，当租户对同一瓶颈环节的需求冲突时，应该保证优先级较高的租户的需求。来自不同租户和各种应用程序类型的需求不同，例如网络搜索、广告、数据分析。因此调度策略也可以不一样。</p><h2 id="能耗">能耗</h2><p>一般能耗是通过架构创新，虚拟化或者调度来降低的。能耗一般作为一个调度目标，采用合适的负载平衡算法，然后可以关闭一些空闲服务器。</p><p>感觉AI还是比较适合在调度里面用，尤其是网络问题里面去用。然后我看老师发我的文章很多，而且都是比较具体的云计算里面的一些算法。我理解的意思是不是去这些文章中参考一下他们的应用场景，然后尝试把MTRL，MORL套过去。</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据中心网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Load Balancing in Data Center Networks A Survey</title>
      <link href="/2022/09/17/ml/lun-wen-yue-du-load-balancing-in-data-center-networks-a-survey/"/>
      <url>/2022/09/17/ml/lun-wen-yue-du-load-balancing-in-data-center-networks-a-survey/</url>
      
        <content type="html"><![CDATA[<h1 id="数据中心网络的架构">数据中心网络的架构</h1><p>==架构可分为以交换机为中心、以服务器为中心和混合结构。==</p><ul><li>在以交换机为中心的架构中，交换机用于在服务器之间提供多条路径并执行数据包转发。</li><li>在以服务器为中心的体系结构中，服务器既执行计算功能，又充当连接到其他服务器的交换机。</li><li>在混合结构中，使用交换机和服务器来执行数据包转发，通常在服务器之间提供长度不等的多条路径。</li></ul><h2 id="以交换机为中心的架构">以交换机为中心的架构</h2><h3 id="fat-tree">Fat-Tree</h3><figure><img src="http://img.meditate.eu.org/note/image-20220918112218519.png" alt="" /><figcaption>k=4的Fat-Tree</figcaption></figure><p><span class="math inline">\(k\)</span>代表pod的数量</p><h3 id="vl2">VL2</h3><figure><img src="http://img.meditate.eu.org/note/image-20220918112402708.png" alt="" /><figcaption>n0=2,n1=4,n2=4的VL2</figcaption></figure><p>边缘交换机有<span class="math inline">\(n_0\)</span>个10GbE端口和<span class="math inline">\(10n_0\)</span>个1GbE端口，聚合交换机有<span class="math inline">\(n_1\)</span>个10GbB端口，核心交换机有<span class="math inline">\(n_2\)</span>个10GbE端口。</p><p>GbE端口：千兆以太网端口</p><h2 id="以服务器为中心的架构">以服务器为中心的架构</h2><h3 id="camcube">CamCube</h3><figure><img src="http://img.meditate.eu.org/note/image-20220918113234243.png" alt="" /><figcaption>27个服务器的CamCube架构</figcaption></figure><p>上图是一个具有27个服务器的CamCube架构。它还提出了一个基于密钥的网络堆栈，以便通过CamCube应用程序接口（API）更好地利用3D Torus架构的容量。以服务器为中心的架构可以显著降低交换机和路由器的成本。由于服务器比交换机需要更少的冷却成本，因此它也是节能的。CamCube的主要缺点在于，对于非基于密钥的应用程序，路径可能变得相当长，路由复杂度可能很高。</p><h2 id="混合架构">混合架构</h2><h3 id="bcube">BCube</h3><figure><img src="http://img.meditate.eu.org/note/image-20220918114249540.png" alt="" /><figcaption>n=4的BCube的架构</figcaption></figure><p>用交换机和具有多个端口的服务器作为转发设备。矩形代表交换机，圆形代表服务器。</p><p><strong>它可以递归定义。<span class="math inline">\(BCube_0\)</span>由连接到n端口交换机的<span class="math inline">\(n\)</span>个服务器组成。<span class="math inline">\(BCube_1\)</span>由n个<span class="math inline">\(BCube_0\)</span>和<span class="math inline">\(n\)</span>个<span class="math inline">\(n\)</span>端口交换机组成。</strong>递归地，<span class="math inline">\(BCube_k（k≥ 1）\)</span> 包含<span class="math inline">\(n\)</span>个<span class="math inline">\(BCube_{k−1}\)</span>和<span class="math inline">\(n^k\)</span>的<span class="math inline">\(n\)</span>端口交换机。总共有<span class="math inline">\(n^{k+1}\)</span>台服务器，具有<span class="math inline">\(k+1\)</span>个端口和<span class="math inline">\(k+1\)</span>个交换机</p><p>然后连接第<span class="math inline">\(j\)</span>个<span class="math inline">\(BCube_{k-1}\)</span>中第<span class="math inline">\(i\)</span>个服务器的第<span class="math inline">\(k\)</span>个端口到第<span class="math inline">\(i\)</span>个<span class="math inline">\(\text{Level}\ k\)</span>交换机的第<span class="math inline">\(j\)</span>个端口。</p><h3 id="dcell">DCell</h3><figure><img src="http://img.meditate.eu.org/note/image-20220918115800292.png" alt="" /><figcaption>n=4的DCell1结构</figcaption></figure><p>DCell也可以递归定义，<span class="math inline">\(DCell_0\)</span>由n个服务器和一个小型交换机构成。每个服务器通过1GbE或10GbE链路连接到小型交换机。在DCell的原型中，<span class="math inline">\(n\)</span>是一个小整数（通常为） <span class="math inline">\(n\le 8\)</span>因此，一个普通的8端口交换机对于该体系结构来说就足够了。</p><h1 id="背景">背景</h1><h2 id="数据中心网络的特点">数据中心网络的特点</h2><ul><li>以小流量为主，缺乏可预测性</li><li>核心层的链路利用率高，丢包率与利用率没有直接关系。数据中心网络中的丢包主要是由流量突发引起的</li></ul><h2 id="链路负载平衡和服务器负载平衡的区别">链路负载平衡和服务器负载平衡的区别</h2><p>服务器负载平衡主要是根据服务器的负载和内容将请求分发到不同的服务器，链路负载平衡是要平衡链路中的流量防止网络拥塞。==本文介绍的链路负载平衡。==</p><h1 id="负载平衡">负载平衡</h1><h2 id="负载平衡的定义">负载平衡的定义</h2><p><strong>负载平衡相当于最小化链路的最大利用率。</strong><span class="math inline">\(s,d\)</span>代表了流的起点和终点，<span class="math inline">\(u,v\)</span>代表了以<span class="math inline">\(s,d\)</span>为起点终点的图中某条边的两个交换机。<span class="math inline">\(c_{u,v}\)</span>代表了链路的最大容量。 <span class="math display">\[min\,\,max_{u,v\in E}\frac{\sum_{s,d}{f_{u,v}^{s,d}}}{c_{u,v}}\]</span></p><h2 id="负载平衡的目标">负载平衡的目标</h2><p>由于数据中心中的应用程序有其特定的需求，负载平衡算法应考虑到这一点，有时需要在不同需求之间进行权衡。负载平衡算法的四个主要目标：==高性能、可扩展性、鲁棒性和能量效率。==这是主要的目标，实际上还会有其他目标。比如各个包的到达的最晚时间。</p><ul><li>高性能：负载均衡算法需要根据应用需求考虑的两个主要需求吞吐量和延迟。</li><li>可扩展性：（1）负载均衡算法是否适用大规模的数据中心网络，并且部署成本是不是高；（2）负载均衡算法是否适用不同的拓扑结构和运行不同应用程序的数据中心环境</li><li>鲁棒性：负载平衡算法如何应对数据中心的故障和拓扑变化是一个关键问题。</li><li>能量效率：负载平衡算法必须考虑能量消耗，并满足用最小设备子集来满足应用要求</li></ul><h1 id="负载平衡算法的两个过程">负载平衡算法的两个过程</h1><p>数据中心网络负载平衡机制的设计分解为两个主要过程：==收集拥塞信息和选择路径。==负载平衡机制的一个关键过程是选择一个或多个适当的度量来表示拥塞，并将拥塞信息传输给将做出负载平衡决策的实体。在获得数据中心网络的拥塞信息后，负载平衡方案需要调度不同路径上的到达流以平衡负载。</p><h2 id="拥塞度量方法">拥塞度量方法</h2><ul><li><strong>基于TCP：</strong>TCP将数据包丢失视为网络拥塞的信号，并在检测到拥塞时减少其拥塞窗口。因此，一些方案利用与TCP或TCP变体类似的信号来检测拥塞。</li><li><strong>发送速率：</strong>流的发送速率是交换机和终端主机可以记录的直接值。通过将增加的发送字节除以时间间隔，可以获得每个流的平均发送速率。该方法通常用于SDN网络，因为OpenFlow交换机自动记录发送的字节，并且控制器可以在任何时间获得该值。</li><li><strong>交换机队列长度：</strong>交换机缓冲区的利用率直接反映了通过该交换机的流量。一些方案使用路径中的交换队列长度来表示路径利用率并检测拥塞。这种方式非常方便在网络方案中使用。</li></ul><figure><img src="http://img.meditate.eu.org/note/image-20220918202521677.png" alt="" /><figcaption>拥塞度量方法</figcaption></figure><h2 id="路径选择">路径选择</h2><ul><li><strong>最少拥塞：</strong>路径选择的理想机制是将每个流分配给最少拥塞的路径。因此，一些方案收集每条路径的利用率信息，并将流量转发到拥塞最小的路径。该方法的性能与路径利用信息的准确性和响应性高度相关。</li><li><strong>较少拥塞：</strong>由于难以实时收集准确的链路利用率，另一种选择路径的方法是将流量从拥塞路径移动到较少拥塞路径。这种方式减少了记录所有路径信息的开销。</li><li><strong>循环：</strong>最初的循环方式是将流<strong>逐个分配</strong>给所有可行路径。由于流和链接信息是不可知的，因此在重负载情况下很容易发生流冲突。因此，一些方案根据数据流的长度或路径利用率来为每条路径加权并循环来平衡流量。该方法的性能与路径权重的精度相关。</li><li><strong>综合分配：</strong>在前三种方法中，流的路径选择过程相互独立，可能导致局部最优。因此，一些方案将一组流聚合起来，并对它们进行综合分配，以实现全局最优。</li></ul><figure><img src="http://img.meditate.eu.org/note/image-20220918202601671.png" alt="" /><figcaption>路径选择算法</figcaption></figure><h1 id="用于负载均衡过程的算法">用于负载均衡过程的算法</h1><h2 id="集中式机制">集中式机制</h2><p>在中央控制器上运行的软件可以收集拥塞信息，并基于控制器的全局视图将流分配给路径。例如上图的控制器利用Openflow协议与交换机通信，并通过网络测量应用程序测量网络。借助测量应用程序，负载平衡应用程序可以轻松获得全局链路利用率和流量信息，并使用这些信息来平衡负载。然而，将引入额外的通信开销以向控制器传输信息。粗时间粒度是集中式机制的另一个限制。大多数集中式控制器无法以足够的粒度轮询信息以处理突发事件，并且这种方式开销比较大。</p><h2 id="分布式机制">分布式机制</h2><p>分布式方案在主机或交换机本地选择路径。它们足够迅速地处理数据中心的流量突发，但对于分布式算法来说，收集全局拥塞信息是一个挑战。此外，分布式算法通常是为对称网络设计的，它们很难对拓扑变化做出反应，例如链路故障和交换机崩溃。</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据中心网络 </tag>
            
            <tag> 负载平衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Distral Robust Multitask Reinforcement Learning</title>
      <link href="/2022/09/15/ml/lun-wen-yue-du-distral-robust-multitask-reinforcement-learning/"/>
      <url>/2022/09/15/ml/lun-wen-yue-du-distral-robust-multitask-reinforcement-learning/</url>
      
        <content type="html"><![CDATA[<p>本文提出了一种同时在多个任务上训练的强化学习方法，叫做Distral。主要的想法是把各个任务上学到的策略进行提纯（distill，本意是蒸馏）得到一个共有的策略，然后再使用这个共有的策略去指导各个特定任务上的策略进行更好的学习。文章称，这种多任务的强化学习方法避免了不同任务产生互斥的梯度，反而干扰学习；同时，也避免了各个任务学习进度不一致，导致某个任务的学习主导了整体的学习。</p><p>这个视频讲得不错，但是有一些错误，以自己笔记为准： https://www.bilibili.com/video/BV1PQ4y1M7nG?share_source=copy_web&amp;vd_source=f038e298fba3a40848f18a2c0868db34</p><p>可以结合这篇文章来看：https://zhuanlan.zhihu.com/p/51091244</p><p>关于蒸馏学习，简单来说就是把一个模型的内容提炼到一个新的模型。可以看这篇：https://zhuanlan.zhihu.com/p/258390817</p><h1 id="distral">Distral</h1><h2 id="模型架构">模型架构</h2><figure><img src="http://img.meditate.eu.org/note/image-20220915152930481.png" alt="" /><figcaption>Distral架构</figcaption></figure><p><span class="math inline">\(\pi_0\)</span>是一个公共策略，是从<span class="math inline">\(\pi_1,\pi_2,\pi_3,\pi_4\)</span>中蒸馏出来的一个<strong>中心策略</strong>。得到<span class="math inline">\(\pi_0\)</span>后会用来指导<span class="math inline">\(\pi_1,\pi_2,\pi_3,\pi_4\)</span>这四个不同的任务的策略。作者说这种基于蒸馏和迁移学习的多任务学习方式效果优于共享模型权重的方式。</p><h2 id="目标函数">目标函数</h2><p><span class="math display">\[\begin{aligned}J\left(\pi_0,\left\{\pi_i\right\}_{i=1}^n\right) &amp;=\sum_i \mathbb{E}_{\pi_i}\left[\sum_{t \geq 0} \gamma^t R_i\left(a_t, s_t\right)-c_{\mathrm{KL}} \gamma^t \log \frac{\pi_i\left(a_t \mid s_t\right)}{\pi_0\left(a_t \mid s_t\right)}-c_{\mathrm{Ent}} \gamma^t \log \pi_i\left(a_t \mid s_t\right)\right] \\&amp;=\sum_i \mathbb{E}_{\pi_i}\left[\sum_{t \geq 0} \gamma^t R_i\left(a_t, s_t\right)+\frac{\gamma^t \alpha}{\beta} \log \pi_0\left(a_t \mid s_t\right)-\frac{\gamma^t}{\beta} \log \pi_i\left(a_t \mid s_t\right)\right]\end{aligned}\]</span></p><p>作者构造了上面这个目标函数，那么我们希望最大化这个目标函数。其中<span class="math inline">\(\alpha =\frac{c_{\text{KL}}}{c_{\text{KL}}+c_{\text{Ent}}}\)</span>，<span class="math inline">\(\beta=\frac{1}{c_\text{KL}+c_\text{Ent}}\)</span>，<span class="math inline">\(c_\text{KL}\)</span>和<span class="math inline">\(c_\text{Ent}\)</span>是决定KL和熵正则化强度的大小的标量因子，二者都是大于0的。</p><p>解释一下额外添加的两项的作用：</p><p><strong>KL散度项正则化项：</strong><span class="math inline">\(c_{\mathrm{KL}} \gamma^t \log \frac{\pi_i\left(a_t \mid s_t\right)}{\pi_0\left(a_t \mid s_t\right)}\)</span>。约束了各个策略<span class="math inline">\(\pi_i\)</span>不要离中心策略<span class="math inline">\(\pi_0\)</span>太远。KL散度衡量了两个分布之间的差异，两个分布完全一致，散度就为0。否则散度较大。这里减去散度项，在使<span class="math inline">\(J\)</span>尽可能大时，散度项就要尽可能小。</p><p><strong>熵正则化项：</strong><span class="math inline">\(-c_{\mathrm{Ent}} \gamma^t \log \pi_i\left(a_t \mid s_t\right)\)</span>。鼓励探索，避免策略只会收敛到解决那个简单的任务。作者举了一个例子：在多任务场景下，如果有一个任务特别的简单，获得奖励非常容易。那么在没有熵正则化项的情况下，模型会收敛到解决那个简单任务然后不再去探索其他较难的任务。这会导致次优策略。这里这个熵项省略了一个乘数，不过并不影响理解它。因为熵的展开本身就存在一个负号，这里其实可以把负号看成一个整体，相当于加上了一个熵项。熵项越大说明策略不确定越高，越鼓励探索，与最大<span class="math inline">\(J\)</span>的目标一致。</p><p>（正则化项：约束优化朝我们想要的方向前进）</p><h2 id="两种优化方式">两种优化方式</h2><h3 id="交替优化">交替优化</h3><p>交替优化就是指先蒸馏一个中心策略，再用中心策略去指导其他的任务。这样依次交替强化两种策略。</p><h4 id="固定pi_i优化pi_0">固定<span class="math inline">\({\pi_i}\)</span>优化<span class="math inline">\(\pi_0\)</span></h4><p>这实际上就是一个蒸馏过程，此时<span class="math inline">\(\pi_i\)</span>项为常数，只需要最大化箭头右边的那项即可。可以用策略梯度等方法。</p><figure><img src="http://img.meditate.eu.org/note/image-20220915162252682.png" alt="" /><figcaption>蒸馏过程</figcaption></figure><h4 id="固定pi_0优化pi_i">固定<span class="math inline">\({\pi_0}\)</span>优化<span class="math inline">\(\pi_i\)</span></h4><p>这样可以对每个<span class="math inline">\(\pi_i\)</span>单独优化，可其看成一个附加熵项的单任务强化学习。推导过程如下：</p><figure><img src="http://img.meditate.eu.org/note/46126295643600.png" alt="" /><figcaption>推一下带熵的reward函数</figcaption></figure><p>这样奖励函数可以用soft Q Learning优化（详见自己的笔记）。</p><figure><img src="http://img.meditate.eu.org/note/46767864258564.png" alt="" /><figcaption>套用SQL的细节</figcaption></figure><p>所以可以套用SQL的Q和V。带进去推一遍即可，得到Q和V。 <span class="math display">\[\begin{aligned}V_i\left(s_t\right) &amp;=\frac{1}{\beta} \log \sum_{a_t} \pi_0^\alpha\left(a_t \mid s_t\right) \exp \left[\beta Q_i\left(a_t, s_t\right)\right] \\Q_i\left(a_t, s_t\right) &amp;=R_i\left(a_t, s_t\right)+\gamma \sum p_i\left(s_{t+1} \mid s_t, a_t\right) V_i\left(s_{t+1}\right)\end{aligned}\]</span> 可以推出<span class="math inline">\(\pi_i\)</span></p><figure><img src="http://img.meditate.eu.org/note/49077424938724.png" alt="" /><figcaption>推导策略i</figcaption></figure><h3 id="联合优化">联合优化</h3><p>依次对<span class="math inline">\(\pi_i\)</span>和<span class="math inline">\(\pi_0\)</span>做SGD，最大化目标函数。联合优化比较简单</p><h4 id="更好的策略表示">更好的策略表示</h4><p><span class="math inline">\(\pi_0\)</span>的估计可以使用简单的玻尔兹曼策略表示，这里的<span class="math inline">\(h_\theta(a_t|s_t)\)</span>就是代表<span class="math inline">\(Q_\theta\)</span> <span class="math display">\[\hat{\pi}_0\left(a_t \mid s_t\right)=\frac{\exp \left(h_{\theta_0}\left(a_t \mid s_t\right)\right.}{\sum_{a^{\prime}} \exp \left(h_{\theta_0}\left(a^{\prime} \mid s_t\right)\right)}\]</span> 对于<span class="math inline">\(\pi_i\)</span>，作者提出了一个更好的表示方式。用<span class="math inline">\(\pi_0\)</span>的共有部分和自己的特有部分来表示。</p><p><img src="http://img.meditate.eu.org/note/image-20220915175805274.png" alt="更好的策略表示" /> <span class="math display">\[\hat{\pi}_i\left(a_t \mid s_t\right)=\hat{\pi}_0^\alpha\left(a_t \mid s_t\right) \exp \left(\beta \hat{A}_i\left(a_t \mid s_t\right)\right)=\frac{\exp \left(\alpha h_{\theta_0}\left(a_t \mid s_t\right)+\beta f_{\theta_i}\left(a_t \mid s_t\right)\right)}{\sum_{a^{\prime}} \exp \left(\left(\alpha h_{\theta_0}\left(a^{\prime} \mid s_t\right)+\beta f_{\theta_i}\left(a^{\prime} \mid s_t\right)\right)\right.}\]</span></p><h4 id="策略梯度">策略梯度</h4><p>于是就利用策略梯度对<span class="math inline">\(\pi_i\)</span>和<span class="math inline">\(\pi_0\)</span>分别优化。 <span class="math display">\[\begin{aligned}\nabla_{\theta_i} J &amp;=\mathbb{E}_{\hat{\pi}_i}\left[\left(\sum_{t \geq 1} \nabla_{\theta_i} \log \hat{\pi}_i\left(a_t \mid s_t\right)\right)\left(\sum_{u \geq 1} \gamma^u\left(R_i^{\mathrm{reg}}\left(a_u, s_u\right)\right)\right)\right] \\&amp;=\mathbb{E}_{\hat{\pi}_i}\left[\sum_{t \geq 1} \nabla_{\theta_i} \log \hat{\pi}_i\left(a_t \mid s_t\right)\left(\sum_{u \geq t} \gamma^u\left(R_i^{\mathrm{reg}}\left(a_u, s_u\right)\right)\right)\right]\end{aligned}\]</span> 其中：<span class="math inline">\(R_i^{\operatorname{reg}}(a, s)=R_i(a, s)+\frac{\alpha}{\beta} \log \hat{\pi}_0(a \mid s)-\frac{1}{\beta} \log \hat{\pi}_i(a \mid s)\)</span> <span class="math display">\[\begin{aligned}\nabla_{\theta_0} J=&amp; \sum_i \mathbb{E}_{\hat{\pi}_i}\left[\sum_{t \geq 1} \nabla_{\theta_0} \log \hat{\pi}_i\left(a_t \mid s_t\right)\left(\sum_{u \geq t} \gamma^u\left(R_i^{\mathrm{reg}}\left(a_u, s_u\right)\right)\right]\right.\\&amp;+\frac{\alpha}{\beta} \sum_i \mathbb{E}_{\hat{\pi}_i}\left[\sum_{t \geq 1} \gamma^t \sum_{a_t^{\prime}}\left(\hat{\pi}_i\left(a_t^{\prime} \mid s_t\right)-\hat{\pi}_0\left(a_t^{\prime} \mid s_t\right)\right) \nabla_{\theta_0} h_{\theta_0}\left(a_t^{\prime} \mid s_t\right)\right]\end{aligned}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Multi-Objective Congestion Control</title>
      <link href="/2022/09/10/ml/lun-wen-yue-du-multi-objective-congestion-control/"/>
      <url>/2022/09/10/ml/lun-wen-yue-du-multi-objective-congestion-control/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是==首篇将多目标强化学习算法应用到拥塞控制（CC）==的一篇偏应用的文章。现有的CC算法无法应对不同程序的新的需求，当应对新的应用时需要学习一个新模型，作者提出了MOCC多目标强化学习框架。在这个框架下，MOCC 进一步应用迁移学习将知识从过去的经验转移到新的应用程序中，即使是不可预见的，也能快速适应新的目标。</p><p>MOCC 明确地将性能目标纳入状态输入和动态奖励函数，并利用带有偏好子网络的新策略神经网络将不同目标与最优控制策略相关联。这允许 MOCC 有效地建立一个单一的相关模型来支持不同的性能目标。在此框架下，MOCC 进一步应用迁移学习，将过去经验中学到的知识快速迁移到新的应用程序中，并针对给定的目标优化 CC 算法。</p><p><strong>总结一下：</strong>就是先预训练一个全局的普适模型，再根据每个应用的需求在应用上迅速地迭代，得到一个应用专属的CC。</p><p>这篇文章的多目标体现在，吞吐量，延迟等目标，不同应用对于这些目标的需求不同。本质上是多目标问题，与应用无关。<strong>感觉有点套了多目标的一个壳子，实际上就是一个简单的标量多目标问题，然后想办法让它适应不同的目标权重组合。</strong></p><h1 id="mocc">MOCC</h1><p>MOCC结合了离线训练和在线学习。离线训练：MOCC在一组分布良好的目标上学习，将性能目标纳入状态输入和动态奖励函数，了解应用程序需求和最优策略之间的相关性。在线学习：面对新应用应用迁移学习经过几次迭代快速收敛到最优策略。</p><h2 id="模型架构">模型架构</h2><p>MOCC 对标准的基于 RL 的 CC 进行了两个主要更改：（1）将偏好子网络合并到策略网络中；（2）在状态输入和动态奖励功能中包括应用需求。这样，MOCC就可以建立各种应用需求和相应的最优码率控制策略之间的关联。</p><h3 id="模型输入">模型输入</h3><p>模型的输入包含了<strong>网络的状态</strong>以及<strong>应用对于不同指标的需求</strong>。</p><ol type="1"><li>应用对于不同指标的需求</li></ol><p>这个需求用一个权重向量表示<span class="math inline">\(\vec{w}=&lt;w_{thr},w_{lat},w_{loss}&gt;\)</span>，$w_i( 0,1 ) <span class="math inline">\(，\)</span>=1$。分别代表吞吐量、延迟和丢包率的权重。</p><ol start="2" type="1"><li>网络的状态</li></ol><p>模型的状态<span class="math inline">\(\vec{g}=&lt;l_t,p_t,q_t&gt;\)</span></p><p><span class="math inline">\(l_t\)</span>：发送率。定义为发送方发送的数据包超过接收方确认的数据包</p><p><span class="math inline">\(p_t\)</span>：潜伏期比率。当前时间间隔𝑡的平均潜伏期与历史上观察到的最小平均潜伏期之比</p><p><span class="math inline">\(q_t\)</span>：延迟梯度。延迟时间对时间的导数</p><p>为了了捕捉网络动态的趋势和变化，模型使用==固定长度的网络统计历史==而不是最近的历史<strong>作为网络的输入</strong>:</p><p><span class="math display">\[\vec{g}_{(t,\eta)}=&lt;\vec{g}_{t-\eta},\vec{g}_{t-\eta+1},\cdots,\vec{g}_{t}&gt;\]</span></p><h3 id="输出">输出</h3><p>actor输出的是一个概率分布，agent挑选一个<span class="math inline">\(a_t\)</span>，网络发送速率<span class="math inline">\(x_t\)</span>的变化如下： <span class="math display">\[x_t=\left\{ \begin{array}{l}    x_{t-1}\times \left( 1+\alpha a_t \right) \ a_t&gt;0\\    x_{t-1}/\left( 1-\alpha a_t \right) \ \ a_t&lt;0\\\end{array} \right.\]</span> 这里 𝛼 是用于抑制振荡的比例因子。代替离散发送速率调整，我们选择连续发送速率调整以提高模型鲁棒性并实现更快的收敛。</p><h3 id="奖励函数">奖励函数</h3><p><span class="math display">\[r_t=w_{thr}*O_{thr}+w_{lat}*O_{lat}+w_{loss}*O_{loss}\]</span></p><p><span class="math inline">\(O_{thr}=\frac{\text{Measured\,\,Throughput}}{\text{Linked\,\,Capacity}}\)</span>，<span class="math inline">\(O_{lat}=\frac{\text{Base Link Latency}}{\text{Measured Latency}}\)</span>，<span class="math inline">\(O_{loss}=1-\frac{\text{Lost Packets}}{\text{Total Packets}}\)</span>，都定义为与奖励正相关，并且除以一个大数是为了标准化到<span class="math inline">\([0,1]\)</span>。</p><h3 id="模型结构">模型结构</h3><p>采用actor-critic的结构，两个模型都引入了==偏好子网络==。</p><figure><img src="http://img.meditate.eu.org/note/image-20220910144043721.png" alt="" /><figcaption>image-20220910144043721</figcaption></figure><h1 id="训练">训练</h1><h2 id="离线训练">离线训练</h2><p>显然，目标空间是无限的，为了高效训练MOCC，文章没有探索整个目标空间，而是在标志性目标的子集上进行训练。</p><p>这一过程分为两个阶段：bootstrapping（引导）and fast traversing （快速遍历）</p><h3 id="bootstrapping">bootstrapping</h3><p>选择一些bootstrapping的权重向量，也就是<strong>自定义一些权重向量</strong>。这些权重向量应当尽量有代表性，文章中是选取了3个不同的权重向量（目标），先在这三个上训练出了一个基础的模型。作者说这一过程需要花费数个小时。</p><p>文章中使用的3个bootstrapping目标为：<span class="math inline">\(&lt;0.6,0.3,0.1&gt;,&lt;0.1,0.6,0.3&gt;,&lt;0.3,0.6,0.1&gt;\)</span></p><p>==值得注意的是：这篇文章中的objectives的定义似乎和我理解的不一样，我理解的是吞吐量、延迟和丢包率是三个目标，而这篇文章中似乎把一个不同的权重向量<span class="math inline">\(\vec{w}=&lt;w_{thr},w_{lat},w_{loss}&gt;\)</span>称为一个目标。详见文章的4.2小节。==</p><h3 id="fast-traversing">fast traversing</h3><p>在快速遍历阶段，在基础模型的基础上，我们通过采用基于邻域的迁移学习策略来加速剩余的 𝜔-3 目标的训练 。该方法基于以下观察：==当两个 RL 具有相近的目标（即相似的权重向量）时，它们的最优解相近。==因此，在训练 RL 时，我们可以通过利用其相邻 RL 的解决方案来加速。</p><p>文章从一个目标迭代训练到它的neighbor，并以循环方式遍历所有目标。请注意，<strong>每次不会将一个权重向量训练到收敛，而只训练几个步骤以实现所有目标的平衡改进。</strong>当模型收敛到所有目标时，整个训练就完成了。如图所示：</p><figure><img src="http://img.meditate.eu.org/note/1662795553488.png" alt="" /><figcaption>1662795553488</figcaption></figure><h4 id="neighbor的定义">neighbor的定义</h4><p>两个权重向量定义为邻居，如果它们最多在两个维度上不同并且每个维度的差异小于步长。例如，在步长为 0.1 时，&lt;0.2, 0.4, 0.4&gt; 和 &lt;0.2, 0.5, 0.3&gt; 是邻居，&lt;0.2, 0.4, 0.4&gt; 和 &lt;0.1, 0.5, 0.4&gt; 是邻居，但 &lt;0.2, 0.4, 0.4&gt; 和 &lt;0.1, 0.3, 0.6&gt; 不是邻居。我们在邻居之间添加边并将所有边权重设置为 1</p><h4 id="查找neighbor">查找neighbor</h4><p>查找neighbor使用的是dijkstra算法</p><p>𝐿 包含一个排序的目标列表，可以用作MOCC 模型的训练顺序</p><p><img src="http://img.meditate.eu.org/note/42692839774128.jpg" alt="42692839774128" style="zoom:55%;" /></p><h3 id="策略优化算法">策略优化算法</h3><p>使用PPO-Clip来训练MOCC <span class="math display">\[L^{CLIP}\left( \theta ,\vec{w} \right) _t=\hat{\mathbb{E}}_t\left[ \min \left( r_t\left( \theta \right) \hat{A}_t,clip\left( r_t\left( \theta \right) ,1-\epsilon ,1+\epsilon \right) \right) \hat{A}_t \right]\]</span></p><p><span class="math inline">\(r_t(\theta)=\frac{\pi_\theta\left(a_t \mid \vec{v}_{(t, \eta)}, \vec{w}\right)}{\pi_{\theta_{o l d}}\left(a_t \mid \vec{v}_{(t, \eta)}, \vec{w}\right)}\)</span>，<span class="math inline">\(\hat{A}\left(\vec{g}_{(t, \eta)}, \vec{w}, a_t\right)=\sum_t \gamma^t r_t-V^{\pi_\theta}\left(\vec{g}_{(t, \eta)}, \vec{w}\right)\)</span>其中<span class="math inline">\(V^{\pi _{\theta}}\left( \vec{g}_{\left( t,\eta \right)},\vec{w} \right)\)</span>是一个惩罚项，为了使奖励不能始终为正，它是有critic网络估计的。</p><p>为了鼓励对策略网络的探索，正如过去的工作 [38] 中所建议的，我们在目标函数<span class="math inline">\(L^{CLIP}\)</span>中添加了一个熵正则化项： <span class="math display">\[L_t^{C L I P+E}(\theta, \vec{w})=L^{C L I P}(\theta, \vec{w})+\beta H\left(\pi_\theta(\cdot \mid \vec{g}(t, \eta), \vec{w})\right)\]</span></p><h2 id="在线调整">在线调整</h2><p>对于一个新应用，基础模型可以给出一个不错的CC方案，同时也可以通过迁移学习迭代少量次数做到很快适应应用，4.8分钟。</p><p>有一个问题：我们不想在适应新应用的同时牺牲旧应用的性能。与所有目标都是人工生成且均匀分布的离线训练不同，真实环境中的目标分布可能存在偏差：有些应用非常频繁，有些则很少见。在这种偏差下，传统的 RL 算法会过度拟合那些新的频繁应用，而逐渐忘记那些旧的稀有应用，这是不可取的。</p><p>为了避免这个问题，MOCC 使用了需求重放学习算法 。在线学习过程中，MOCC 存储长期遇到的应用（权重向量）。对于每个在线训练步骤，模型都在<strong>当前目标</strong>和从<strong>存储的应用程序池</strong>中随机抽取的旧目标上进行训练。将在线学习目标定义为： <span class="math display">\[L_{\text {online }}(\theta)=\frac{1}{2} *\left[L^{C L I P+E}\left(\theta, \vec{w}_i\right)+L^{C L I P+E}\left(\theta, \vec{w}_j\right)\right]\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多目标强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Multi-Task Reinforcement Learning with Soft Modularization</title>
      <link href="/2022/08/25/ml/lun-wen-yue-du-multi-task-reinforcement-learning-with-soft-modularization/"/>
      <url>/2022/08/25/ml/lun-wen-yue-du-multi-task-reinforcement-learning-with-soft-modularization/</url>
      
        <content type="html"><![CDATA[<p>将一个基础的网络分层并模块化，使用一个路由网络来为每个任务选择不同的模块，路由网络也可以学习。这就是所谓的软模块。</p><p>用到的是SAC算法的改进型，文中引用的确实最原始的SAC文章（坑死）。改进的SAC取缔了V网络，并且温度系数<span class="math inline">\(\alpha\)</span>不再固定死，而是通过梯度下降更新。<strong>SAC的温度系数自学版本没有完全理解，最好去看看。</strong></p><h1 id="soft-modularization">Soft Modularization</h1><figure><img src="http://img.meditate.eu.org/note/image-20220825211929434.png" alt="" /><figcaption>soft modularization</figcaption></figure><p>Base Policy有L层，每层由n个模块构成。Routing网络由L-1层的输出，每层都输出n*n的矩阵，代表了每个模块与下一层中模块之前连接的权重。<span class="math inline">\(s_t\)</span>代表当前状态，<span class="math inline">\(z_{\tau}\)</span>代表了与任务相关的one-hot编码。两个输入经过全连接层都会得到一个D维的向量，D在这里是一个超参数。</p><p>最后Base Policy输出的是<span class="math inline">\(\mu ,\sigma\)</span>代表一个分布。</p><p>不同任务的难易程度不同造成了收敛速度也不同。因此要在各个任务的损失函数前加个权重，这个权重与<span class="math inline">\(\alpha\)</span>相关。 <span class="math display">\[w_{i} =\frac{e^{-\alpha _{i} } }{\sum_{j=1}^{M} e^{-\alpha _{i}} }\]</span> 而<span class="math inline">\(\alpha\)</span>则是通过梯度下降更新的。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Multi-Task Deep Reinforcement Learning for Continuous Action Control</title>
      <link href="/2022/08/24/ml/lun-wen-yue-du-multi-task-deep-reinforcement-learning-for-continuous-action-control/"/>
      <url>/2022/08/24/ml/lun-wen-yue-du-multi-task-deep-reinforcement-learning-for-continuous-action-control/</url>
      
        <content type="html"><![CDATA[<p>本文基于机器人场景，提出了一种multi-DDPG的算法，将DDPG拓展到了多任务场景，使机器人能够学习多个连续的动作。并且引入mlpconv显著减少了模型参数量，将图像和传感器数据组合为输入。</p><h1 id="mlpconv">MLPConv</h1><h2 id="mlpconv-1">mlpconv</h2><figure><img src="http://img.meditate.eu.org/note/20210213230837584.png" alt="" /><figcaption>mlpconv的结构</figcaption></figure><p>一般卷积操作可以看成特征的提取操作，而一般卷积一层只相当于一个线性操作，所以其只能提取出线性特征。所以作者就想能否在卷积层后也加入一个MLP使得每层卷积操作能够提取非线性特征。而为了减少参数量，又用1*1的卷积层模拟了MLP</p><p>一个mlpconv卷积块是1个卷积后加<strong>两个</strong>1*1的卷积，但是每个1*1卷积后面都跟着一个ReLu, 所以可以引入更多的非线性。</p><p>这里的图画的是真的坑，这里的<span class="math inline">\(C_2\)</span>指的是1*1卷积核的数量，展开的这一个长条形的向量指的是同一个位置的像素在经过<span class="math inline">\(C_2\)</span>个卷积过后的值。中间的类似全连接的部分指的是1*1卷积，因为对同一个像素点施加不同的1*1卷积就类似于全连接的结构。也就是相当于在不同通道之间进行全连接，==而不是把特征图展平。==</p><h2 id="全局平均池化">全局平均池化</h2><p>mlpconv还提出了全局平均池化的概念。</p><p>Global Average Pooling主要为了解决全连接层参数过多的问题，早期对于分类问题，最后一个卷积层的 Feature Map 通常与全连接层连接，最后通过 <strong>softmax 逻辑回归分类</strong>。全连接层带来的问题就是参数空间过大，容易过拟合</p><p>global average pooling的概念非常简单，分类任务有多少个类别,就控制最终产生多少个feature map，也就是多少通道数。然后对于整个特征图做平均池化。就得到与通道数相等的类别数。</p><h1 id="multi-ddpg">Multi-DDPG</h1><figure><img src="http://img.meditate.eu.org/note/image-20220824144142878.png" alt="" /><figcaption>multi-DDPG结构</figcaption></figure><p>multi-DDPG是多Actor，单Critic的结构。也就意味着一个Critic要对所有的Actor打分。在Critic模型中，最后一个全连接层是非共享的，前面的部分都是对个Actor共享的。</p><figure><img src="http://img.meditate.eu.org/note/image-20220824144310836.png" alt="" /><figcaption>multi-DDPG算法流程</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Towards Impartial Multi-Task Learning</title>
      <link href="/2022/08/16/ml/lun-wen-yue-du-towards-impartial-multi-task-learning/"/>
      <url>/2022/08/16/ml/lun-wen-yue-du-towards-impartial-multi-task-learning/</url>
      
        <content type="html"><![CDATA[<p>文章主要提出了一种方法能够均衡的学习multi task learning问题，这种方法的优点是不需要对分布有任何假设，并且对gradient scale的过程是和训练过程同步的，同时文章发现对loss balance和gradients balance是互补的，因此提出了一种混合的方法能够更好平衡gradients和losses。</p><p>这篇文章的推导过程还是比较精妙的，我只看懂了70%。</p><h1 id="算法">算法</h1><p>MTL的问题中平衡方法分为loss balance和gradients balance两种，这篇文章综合了这两种方法。</p><p>详细解读过程可以看论文阅读的PDF。</p><figure><img src="http://img.meditate.eu.org/note/image-20220816171337469.png" alt="" /><figcaption>IMTL的算法过程</figcaption></figure><p>gradients balance在文章中提出的方法是IMTL-G，用来更新共享层的参数。</p><p>loss balance提出的方法是IMTL-L，通过认为构造scaled loss函数来达到目的。</p><p>文章中提出的scaled loss如下所示： <span class="math display">\[g\left( s \right) =e^sL\left( \theta \right) -s\]</span> 这个函数是关于s和<span class="math inline">\(\theta\)</span>的函数，s是缩放系数，<span class="math inline">\(\theta\)</span>是各个任务单独的权重，这样就可以在模型中分别求偏导来更新两个变量。</p><p>$L( ) <span class="math inline">\(是原始损失，\)</span>e^s$是为了将s映射到正实数。-s是正则化项，为了避免s找到负无穷的平凡解。</p><p>构造scaled loss的原因和过程可以看论文PDF。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Task Switching Network for Multi-task Learning</title>
      <link href="/2022/08/16/ml/lun-wen-yue-du-task-switching-network-for-multi-task-learning/"/>
      <url>/2022/08/16/ml/lun-wen-yue-du-task-switching-network-for-multi-task-learning/</url>
      
        <content type="html"><![CDATA[<p>这篇论文提出了任务交换网络（TSN），首次使用单编码器-单解码器的结构显著减少了参数量。</p><h1 id="tsn">TSN</h1><figure><img src="http://img.meditate.eu.org/note/image-20220808230903682.png" alt="" /><figcaption>TSN的总体结构</figcaption></figure><p>主干网络是Resnet-18，解码器中每一层会接受上一层中上采样后的特征图拼接上本层的特征图。</p><p>与以往的模型最大的区别在于输出后面只接了一个头（decoder）。做卷积之后利用这一个头去完成不同的任务。为了区分不同的任务，引入了Task Embedding，为每个任务得到一个<span class="math inline">\(l_{\tau}\)</span>向量通过某种方式区分不同的任务。输出通道数的选择也是有讲究的，一般<strong>取所有任务中所需输出的最大的通道数</strong>。这样对于其他的任务，可以沿通道执行平均池化来适应不同的任务。（多说一句，平均池化是没有参数的，所以不会增加额外的参数）</p><h2 id="task-embedding-network">Task Embedding Network</h2><p>这是一个得到<span class="math inline">\(l_{\tau}\)</span>向量的过程。如图中的左下角</p><p>首先，要为每个任务初始化一个d维的条件向量。根据执行的任务的不同，选择任务对应的向量<span class="math inline">\(v_{\tau}\)</span>。然后经过一个全连接层，输出一个<span class="math inline">\(l_{\tau}\)</span>，仍然为d维。 <span class="math inline">\(v_{\tau}\)</span>的选择有两种：</p><ol type="1"><li>不同的任务的条件向量是正交</li></ol><p><span class="math display">\[v_{\tau ^1}^Tv_{\tau ^2}=\begin{cases}    \frac{d}{T},&amp;       \tau _1=\tau _2\\    0,&amp;     otherwise\\\end{cases}\]</span></p><ol start="2" type="1"><li><span class="math inline">\(v_{\tau}\)</span>是高斯随机矩阵</li></ol><p><span class="math display">\[v_{\tau}\sim N\left( 0_d,\text{diag}\left( 1_d \right) \right)\]</span></p><h2 id="conditional-convolution-module">Conditional Convolution Module</h2><p>也就是A模块，其结构如图中右下角所示</p><p>输入的张量的通道数为c</p><p>上一步中得到的<span class="math inline">\(l_{\tau}\)</span>会经过两个全连接层，将d维的向量映射到c维去。这样会分别得到两个向量<span class="math inline">\(\gamma\)</span>和<span class="math inline">\(\beta\)</span>。</p><p>随后经过AdaIN函数，其中的<span class="math inline">\(\mu\)</span>代表均值，<span class="math inline">\(\sigma ^2\)</span>代表方差。</p><p>这两个值是通过Instance Normalization（IN）得到的。具体可见：https://blog.csdn.net/u011447962/article/details/117714531?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-117714531-blog-125660719.pc_relevant_show_downloadRating&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-117714531-blog-125660719.pc_relevant_show_downloadRating&amp;utm_relevant_index=2</p><p>简单来说就是对于每个通道内部求均值方差。 <span class="math display">\[AdaIN\left( \hat{x},\beta ,\gamma \right) =\gamma \frac{\left( \hat{x}-\mu \right)}{\sqrt{\sigma ^2}}+\beta\]</span> 所以这个式子就是做IN的过程。<span class="math inline">\(\gamma\)</span>和<span class="math inline">\(\beta\)</span>称为缩放系数和偏移量。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】Multi-task Learning with Attention for End-to-end Autonomous Driving</title>
      <link href="/2022/08/16/ml/lun-wen-yue-du-multi-task-learning-with-attention-for-end-to-end-autonomous-driving/"/>
      <url>/2022/08/16/ml/lun-wen-yue-du-multi-task-learning-with-attention-for-end-to-end-autonomous-driving/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是自动驾驶领域的文章，自动驾驶领域往往有两类任务：<strong>感知环境</strong>（如：语义分割），<strong>驾驶决策</strong>（根据周围环境做出相应的操作）。</p><p>这篇文章聚焦于自动驾驶中的点对点的导航问题，将多任务学习引入了自动驾驶，并且引入了注意力机制有效提高了准确率，文末也通过可视化图热图对注意力机制进行了定性的分析。本文的模型能够识别红绿灯（以往的模型做不到）。</p><p><strong>这篇文章是基于RGB单目相机，并且是端到端的，采用了CIL框架</strong>。（端到端指的是输入是原始数据，输出是最后的结果，原来输入端不是直接的原始数据，而是在原始数据中提取的特征）</p><p>个人认为这篇文章最大的创新点就是利用注意力机制在一个encoder上得到了两个type（对应与上面提到的自动驾驶的两类任务），然后在两个type后面接不同的解码器做不同的任务。</p><h1 id="cbam">CBAM</h1><p>文章中用到了CBAM模块，首先对它进行一个介绍。</p><p><strong>卷积块注意模块（CBAM）</strong>融合了通道注意力机制和空间注意力机制。采用模块化的设计，几乎可以没有开销地嵌入任何网络。</p><p>总体的结构如下图，它首先做通道注意力，再做空间注意力</p><figure><img src="http://img.meditate.eu.org/note/image-20220810100551027.png"alt="卷积块注意模块（CBAM）" /><figcaption aria-hidden="true">卷积块注意模块（CBAM）</figcaption></figure><h2 id="通道注意力模块">通道注意力模块</h2><figure><img src="http://img.meditate.eu.org/note/image-20220810100817512.png"alt="通道注意力模块" /><figcaption aria-hidden="true">通道注意力模块</figcaption></figure><ol type="1"><li>首先在每个通道上做最大池化和平均池化</li><li>分别将两个向量输入一个全连接的网络，输出要与输入向量的长度保持一致</li><li>将两个向量相加，经过Sigmoid函数。得到的向量表示每个通道对应的权重。</li><li>将向量与输入的特征图的每个对应的通道相乘</li></ol><h2 id="空间注意力模块">空间注意力模块</h2><figure><img src="http://img.meditate.eu.org/note/image-20220810101815278.png"alt="空间注意力模块" /><figcaption aria-hidden="true">空间注意力模块</figcaption></figure><ol type="1"><li>沿着通道做最大池化和平均池化。以最大池化为例：就是在所有通道的对应像素点中取一个最大值。得到两个二维的特征图。</li><li>将两个特征图沿着通道拼起来，通过一个卷积层，文章中是7*7的卷积，得到一个<strong>二维</strong>的特征图。</li><li>经过Sigmoid函数，得到的是特征图中每个像素点对应的权重。</li><li>将权重图与输入图中对应位置相乘。</li></ol><h2 id="resnet引入cbam">ResNet引入CBAM</h2><ul><li>CBAM并不会影响原来的网络结构</li><li>CBAM加在残差连接之前</li></ul><figure><img src="http://img.meditate.eu.org/note/image-20220810102431347.png"alt="Resnet中加入CBAM" /><figcaption aria-hidden="true">Resnet中加入CBAM</figcaption></figure><h1 id="网络结构">网络结构</h1><figure><img src="http://img.meditate.eu.org/note/image-20220810103009942.png"alt="模型结构" /><figcaption aria-hidden="true">模型结构</figcaption></figure><h2 id="encoder">Encoder</h2><figure><img src="http://img.meditate.eu.org/note/image-20220810123214170.png"alt="Encoder的结构" /><figcaption aria-hidden="true">Encoder的结构</figcaption></figure><p>主干网络采用了ResNet-34，引申出了两种type。type1后续会接上decoder用于处理语义分割，深度预测的任务。type2会去处理信号灯分类和控制预测。作者也对这种操作做了简单的说明，因为语义分割和深度预测往往需要更高分辨率的特征图以免丢失细节，而信号灯分类和控制预测需要隐藏抽象特征。</p><p>注意这里的ConvBlock，经过池化以后通道数是不变的，为了能与下一层的特征图相加，接上了一个卷积来使通道数翻倍。</p><h2 id="decoder">Decoder</h2><p>这一部分文章写得有点坑，图中两个decoder的结构参考了一篇论文，然而那篇论文又参考了另一篇论文o(╥﹏╥)o。然而，我读了两篇论文后，发现这里的结构不可能完全与它们一致。所以实际结构怎么样只有看了源码才知道。不过这并不影响理解这部分。</p><p>实际上简单思考也知道，由于<strong>decoder的输出和网络的输入图像是一样大小的</strong>。因此，这里的decoder肯定是用了几个上采样调整到与原图一样的尺寸，最后接上一个softmax。</p><p>作者也说了，经过实验发现，当segmentation的decoder深度大于depth的decoder深度时，模型的整体效果比较好。</p><h2 id="信号灯分类">信号灯分类</h2><p>分为四类：红，黄，绿，无信号灯。对采集到的每一帧都给出一个分类</p><p>应该就是连个全连接层。</p><h2 id="驾驶模块">驾驶模块</h2><p>这里会有两个额外的输入信息，分别是车辆的速度v和更高级别的命令c（如左转）。type2的特征图展开成一个向量。</p><p>驾驶模块中接了四个不同的头，分别对应于4中不同的高级命令（车道保持，左转，右转，直行）。根据输入的高级命令c，选择不同的头输出操作指令。这种多头的结构要好于单头（之前的论文证明过）。</p><p><strong>说明：</strong>车辆在面对十字路口中，往往可以有多个指令的选择，这会引起歧义。CIL框架为了解决这个问题会给出一个高级命令（如左转）。然后模型根据这个命令给出更加基础的操作（踩油门，踩刹车，转方向盘）。这个高级指令在这篇文章中是使用A*算法做路径规划给出的。它对没一帧的画面都会给出一个c指示下一步前进的方向。</p><h2 id="损失函数">损失函数</h2><p><span class="math display">\[L_{total}=\lambda _{control}L_{control}+\lambda _{tl}L_{tl}+\lambda_{seg}L_{seg}+\lambda _{dep}L_{dep} \\ L_{control}=\sum_{c=1}^3{\gamma_cL_c}\]</span></p><p><span class="math inline">\(L_{control}\)</span>和<spanclass="math inline">\(L_{dep}\)</span>采用均方差损失，<spanclass="math inline">\(L_{tl}\)</span>和<spanclass="math inline">\(L_{seg}\)</span>采用交叉熵损失。</p><p>第二个式子中c=1代表转向，c=2代表油门，c=3代表刹车</p><p><span class="math inline">\(\lambda\)</span>和<spanclass="math inline">\(\gamma\)</span>凭经验设置。</p><h1 id="实验">实验</h1><h2 id="数据集增强和数据集均衡">数据集增强和数据集均衡</h2><p>为了扩充数据集，作者做了数据集增强。</p><p>采集到的数据集是不平衡的（直线行驶特别多），于是文章采用降采样的方法，让直线行驶选中的概率降低。实测下来数据集均衡对于模型非常重要。</p><p>实验结果看看table就明白了。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2022/06/24/develop/docker/"/>
      <url>/2022/06/24/develop/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="docker">docker</h1><p>英文文档：https://docs.docker.com/</p><p>docker中文文档：https://gitee.com/docker_practice/docker_practice#https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fyeasy%2Fdocker_practice</p><h2 id="一-docker的定义">一 docker的定义</h2><p>docker就是一种容器应用，用于更好地发布应用。docker可以直接装一个个的软件服务。当我们需要安装redis，MySQL时我们需要下载很多的环境，这会非常的繁琐。并且，当我们想将软件给其他人时，往往会出现“这段代码在我的机器上没问题啊”的问题。docker就很好地解决了这个问题，他将你的应用和你的环境做一个打包，就像一个个的集装箱一样，将各个应用进行隔离，这样就可以<strong>运行你的应用而不需要安装环境</strong>了。</p><p>当我们把应用和容器打包到一起时，我们称之为<strong>镜像</strong>。</p><p><strong>更高效的利用系统资源</strong></p><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，<code>Docker</code> 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><p><strong>更快速的启动时间</strong></p><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code> 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><p><strong>一致的运行环境</strong></p><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p><p><strong>持续交付和部署</strong></p><p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps">DevOps (opens new window)</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p><p>使用 <code>Docker</code> 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a href="https://vuepress.mirror.docker-practice.com/image/dockerfile/">Dockerfile</a> 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(Continuous Integration) (opens new window)</a>系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery">持续部署(Continuous Delivery/Deployment) (opens new window)</a>系统进行自动部署。</p><p>而且使用 <a href="https://vuepress.mirror.docker-practice.com/image/build.html"><code>Dockerfile</code></a> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><p><strong>更轻松的迁移</strong></p><p>由于 <code>Docker</code> 确保了执行环境的一致性，使得应用的迁移更加容易。<code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><p><strong>更轻松的维护和扩展</strong></p><p><code>Docker</code> 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&amp;image_filter=official">官方镜像 (opens new window)</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本</p><p><strong>对比传统虚拟机</strong></p><table><thead><tr class="header"><th style="text-align: left;">特性</th><th style="text-align: left;">容器</th><th style="text-align: left;">虚拟机</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">启动</td><td style="text-align: left;">秒级</td><td style="text-align: left;">分钟级</td></tr><tr class="even"><td style="text-align: left;">硬盘使用</td><td style="text-align: left;">一般为 <code>MB</code></td><td style="text-align: left;">一般为 <code>GB</code></td></tr><tr class="odd"><td style="text-align: left;">性能</td><td style="text-align: left;">接近原生</td><td style="text-align: left;">弱于</td></tr><tr class="even"><td style="text-align: left;">系统支持量</td><td style="text-align: left;">单机支持上千个容器</td><td style="text-align: left;">一般几十个</td></tr></tbody></table><h2 id="二-docker安装">二 docker安装</h2><p>https://docs.docker.com/engine/install/centos/#install-using-the-convenience-script</p><p>只有centos7+才能安装docker</p><p>docker安装方式有很多，推荐使用脚本安装。可以在任意Linux系统上安装</p><p>首先下载docker安装的脚本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> -fsSL get.docker.com -o get-docker.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过下载的脚本来下载docker引擎，推荐使用阿里云镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sh</span> get-docker.sh --mirror Aliyun<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动docker服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span> <span class="token comment">#将docker加入开机自启动的列表</span>systemctl start <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>推荐将当前用户加入docker组</p><p>创建docker组</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">groupadd</span> <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将当前用户加入docker组</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">usermod</span> -aG <span class="token function">docker</span> <span class="token environment constant">$USER</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试docker安装是否正确</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> version<span class="token function">docker</span> info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="三-docker的核心概念">三 docker的核心概念</h2><p><strong>镜像 Image</strong></p><p>一个镜像就代表一个软件。</p><p><strong>容器 Container</strong></p><p>一个镜像运行一次就会生成一个容器。容器就是一个运行的软件服务。</p><p>举例：我可以在一台电脑中开多个Chrome浏览器。</p><p><strong>仓库 docker repository</strong></p><p>docker在全球范围内维护了一个镜像仓库。类似于maven</p><p><strong>远程仓库：docker hub</strong></p><p>https://registry.hub.docker.com/_/tomcat?tab=tags</p><p><strong>本地仓库</strong>：用来存储在使用docker过程中的相关镜像</p><h2 id="四-配置阿里云镜像加速">四 配置阿里云镜像加速</h2><p>阿里云会为每个开发者分配一个单独的镜像</p><p>https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> -p /etc/docker<span class="token function">sudo</span> <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'&#123;  "registry-mirrors": ["自己的url"]&#125;EOF</span><span class="token function">sudo</span> systemctl daemon-reload<span class="token function">sudo</span> systemctl restart <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五-镜像操作">五 镜像操作</h2><h3 id="查看本地仓库有那些镜像">1 查看本地仓库有那些镜像</h3><figure><img src="http://img.meditate.eu.org/note/image-20211226161858115.png" alt="" /><figcaption>image-20211226161858115</figcaption></figure><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看本地仓库有那些镜像</span><span class="token function">docker</span> imgae <span class="token function">ls</span>或者<span class="token function">docker</span> images<span class="token comment">#查看指定镜像名</span><span class="token function">docker</span> images 镜像名<span class="token comment">#只列出镜像id</span><span class="token function">docker</span> images -q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>docker可以通过id和名称:版本来查找镜像</p><h3 id="下载镜像">2 下载镜像</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull name:tag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="搜索镜像">3 搜索镜像</h3><p>查看镜像是否存在，不能查看版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> search name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="删除镜像">4 删除镜像</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#正常删除。只能删除没有运行过的镜像</span><span class="token function">docker</span> image <span class="token function">rm</span> 镜像名（name:tag）<span class="token operator">|</span>镜像id<span class="token comment">#强制删除。镜像和容器一起删除</span><span class="token function">docker</span> image <span class="token function">rm</span> -f 镜像名（name:tag）<span class="token operator">|</span>镜像id<span class="token comment">#举例：删除所有Tomcat的镜像</span><span class="token function">docker</span> image <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> images tomcat -q<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="镜像备份和恢复">5 镜像备份和恢复</h3><p>可以将docker打包成一个tar包，方便传输和储存。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#打包镜像</span><span class="token function">docker</span> save 镜像名：版本 -o <span class="token punctuation">(</span>镜像名-版本号<span class="token punctuation">)</span>.tar<span class="token comment">#恢复镜像</span><span class="token function">docker</span> load -i <span class="token punctuation">(</span>tar包的名字<span class="token punctuation">)</span>.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看镜像的构建历史">6 查看镜像的构建历史</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">history</span> 镜像名：版本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="六-容器的操作">六 容器的操作</h2><h3 id="查看正在运行的容器">1 查看正在运行的容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">ps</span><span class="token comment">#查看所有容器，包括停止的</span><span class="token function">docker</span> <span class="token function">ps</span> -a<span class="token comment">#查看所有容器的id</span><span class="token function">docker</span> <span class="token function">ps</span> -aq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行一个容器">2 运行一个容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run name:tag或者<span class="token function">docker</span> run imageid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>container id(容器id)</p><p>imgae(基于哪个镜像)</p><p>command（容器内启动服务的命令）</p><p>names（容器的名称，可以自己指定，不指定则由docker自动分配）</p><figure><img src="http://img.meditate.eu.org/note/image-20211226164719464.png" alt="" /><figcaption>image-20211226164719464</figcaption></figure><h3 id="容器映射">3 容器映射</h3><p>由于docker是操作系统层面的隔离，所以容器有自己的端口。为了在外部访问到容器，要将容器的端口与外部主机的端口相映射。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">8080</span>（宿主机）:8080 tomcat:8.0 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-p可以写多个映射</p><h3 id="后台启动">4 后台启动</h3><p>以守护进程的方式启动。否则每启动一个容器就要重新打开一个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">8080</span>（宿主机）:8080 -d tomcat:8.0 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="给容器取名">5 给容器取名</h3><p>这个name必须是唯一的</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">8080</span>（宿主机）:8080 -d --name tomcat01 tomcat:8.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="停止-重启-启动-暂停-恢复容器">6 停止 重启 启动 暂停 恢复容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#停止</span><span class="token function">docker</span> stop 容器名称<span class="token operator">|</span>容器id<span class="token comment">#重启</span><span class="token function">docker</span> restart 容器名称<span class="token operator">|</span>容器id<span class="token comment">#启动</span><span class="token function">docker</span> start 容器名称<span class="token operator">|</span>容器id<span class="token comment">#暂停</span><span class="token function">docker</span> pause 容器名称<span class="token operator">|</span>容器id<span class="token comment">#恢复</span><span class="token function">docker</span> unpause 容器名称<span class="token operator">|</span>容器id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="杀死容器">7 杀死容器</h3><p>与stop不同，kill容器容器中不会进行后续操作，属于强制停止。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">kill</span> 容器名称<span class="token operator">|</span>容器id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="删除容器">8 删除容器</h3><p>删除容器不会影响到镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#不在运行的容器</span><span class="token function">docker</span> <span class="token function">rm</span> 容器名称<span class="token operator">|</span>容器id<span class="token comment">#强制删除容器</span><span class="token function">docker</span> <span class="token function">rm</span> -f 容器名称<span class="token operator">|</span>容器id<span class="token comment">#删除所有容器</span><span class="token function">docker</span> <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> -aq<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看容器日志">9 查看容器日志</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> logs 容器名称<span class="token operator">|</span>容器id<span class="token comment">#查看实时的日志</span><span class="token function">docker</span> logs -f 容器名称<span class="token operator">|</span>容器id<span class="token comment">#加上宿主机中的时间</span><span class="token function">docker</span> logs -t 容器名称<span class="token operator">|</span>容器id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="进入容器的内部">10 进入容器的内部</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it 容器名称<span class="token operator">|</span>容器id <span class="token function">bash</span><span class="token comment">#-it 代表以交互模式进入</span><span class="token comment">#与容器中的bash交互</span><span class="token comment">#退出容器</span><span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="容器与宿主机之间的文件传输">11 容器与宿主机之间的文件传输</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#将容器中的文件或目录拷贝到宿主机</span><span class="token function">docker</span> <span class="token function">cp</span> 容器名称<span class="token operator">|</span>容器id:文件或目录 宿主机中的目录<span class="token comment">#将宿主机上的文件或目录拷贝到容器中</span><span class="token function">docker</span> <span class="token function">cp</span> 宿主机中的目录或文件 容器名称<span class="token operator">|</span>容器id:容器的目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看容器内运行的进程">12 查看容器内运行的进程</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">top</span> 容器名称<span class="token operator">|</span>容器id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看容器内细节指令">13 查看容器内细节指令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> inspect 容器名称<span class="token operator">|</span>容器id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="容器的数据卷机制">14 容器的数据卷机制</h3><p>data volume：用来实现容器中数据和宿主机中的数据进行映射。通俗来说就是设置一块空间与容器中的目录和宿主机中的目录进行映射。这样容器空间与宿主机的目录就实现了双向绑定。随便更改哪边另一边都会更改。</p><h4 id="数据卷挂载">14.1 数据卷挂载</h4><p><strong>数据卷只能在容器首次启动时设置</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#使用绝对路径设置数据卷（可以多个）</span><span class="token function">docker</span> run -v 宿主机绝对路径:容器内路径<span class="token comment">#注意：这种方式启动时会将容器路径的内容全部清空</span><span class="token function">docker</span> run -v 宿主机绝对路径:容器内路径:ro<span class="token comment">#设置ro时表示容器内的目录是只读的。只能通过宿主机操作。</span><span class="token comment">#使用别名方式设置数据卷</span><span class="token function">docker</span> run -v 别名:容器内路径<span class="token comment">#例如</span><span class="token function">docker</span> run -v aa:/usr/local/tomcat/webapps<span class="token comment">#aa代表docker数据卷中的别名，aa不存在会自动创建，存在则直接使用</span><span class="token comment">#使用别名方式会保留容器路径原始内容，前提是别名对应的路径不存在内容</span><span class="token comment"># 别名挂载还有一种匿名挂载</span><span class="token function">docker</span> run -d  -v 容器内目录  镜像名/id  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>docker根据别名创建的目录一般在/var/lib/docker/volume</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看所有挂载的卷</span><span class="token function">docker</span> volume <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="数据卷容器">14.2 数据卷容器</h4><p>一个容器可以通过<code>volumes from</code>直接使用其他容器的数据卷挂载方式。并且这样指定后，多个容器是共享数据卷的，共享的数据卷只要还有容器使用它就不会消失。可以通过这种 机制来实现配合文件的共享或者数据库的数据同步等操作。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it --name container02 --volumes from container01 镜像名/id  <span class="token comment"># 将两个容器进行挂载</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="将容器打包成一个镜像">15 将容器打包成一个镜像</h3><p>将自己的容器打包成一个镜像，这样以后只需要运行相应的镜像就行了</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> commit -m <span class="token string">"描述信息"</span> -a <span class="token string">"作者"</span> 容器名称<span class="token operator">|</span>容器id 镜像名：版本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看容器或者镜像的信息">16 查看容器或者镜像的信息</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> inspect 镜像<span class="token operator">|</span>容器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="七-镜像构成原理">七 镜像构成原理</h2><p><strong>自己打包的镜像为什么那么大？</strong></p><p>因为容器是一种轻量级的，可执行的独立软件包，它包含了软件运行的库。</p><p><strong>为什么从官方下载的镜像那么小？</strong></p><p>因为docker使用了联合文件系统。每个镜像存在一个base镜像，这样就实现了底层镜像的复用，不用存储每个重复的运行依赖。因此，当我们下载Tomcat8.0时，会发现我们要下载许多东西，当我们下载Tomcat8.1时会发现下载的东西变少了。</p><p>每个镜像都由很多层次构成，Docker 使用 <a href="https://en.wikipedia.org/wiki/UnionFS">Union FS (opens new window)</a>将这些不同的层结合到一个镜像中去。</p><p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。</p><p>Docker 在 OverlayFS 上构建的容器也是利用了类似的原理。</p><h2 id="八-dockerfile">八 dockerFile</h2><h3 id="概念">1 概念</h3><p>dockerfile是用来构建docker镜像的文件，是一个<strong>命令参数脚本</strong>。</p><p>官方镜像的很多都是基础包，我们通常会构建自己的镜像。</p><p>构建步骤：</p><ol type="1"><li>编写一个dockerfile文件</li><li>docker build为一个镜像</li><li>docker run运行镜像</li><li>docker push发布镜像</li></ol><h3 id="指令">2 指令</h3><table><thead><tr class="header"><th style="text-align: center;">命令</th><th style="text-align: center;">效果</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">FROM</td><td style="text-align: center;">基础镜像：Centos/Ubuntu</td></tr><tr class="even"><td style="text-align: center;">MAINTAINER</td><td style="text-align: center;">镜像作者+邮箱</td></tr><tr class="odd"><td style="text-align: center;">RUN</td><td style="text-align: center;">镜像构建的时候需要运行的命令</td></tr><tr class="even"><td style="text-align: center;">ADD</td><td style="text-align: center;">为镜像添加内容（压缩包）</td></tr><tr class="odd"><td style="text-align: center;">WORKDIR</td><td style="text-align: center;">镜像工作目录（进入容器时的目录）</td></tr><tr class="even"><td style="text-align: center;">VOLUME</td><td style="text-align: center;">挂载的目录</td></tr><tr class="odd"><td style="text-align: center;">EXPOSE</td><td style="text-align: center;">暴露端口配置</td></tr><tr class="even"><td style="text-align: center;">CMD/ENTRYPOINT</td><td style="text-align: center;">指定这个容器启动时要运行的命令（CMD替代先前命令，ENTRYPOINT在先前命令后追加）</td></tr><tr class="odd"><td style="text-align: center;">COPY</td><td style="text-align: center;">类似于ADD，将文件拷贝到镜像中</td></tr><tr class="even"><td style="text-align: center;">ENV</td><td style="text-align: center;">构建时设置环境变量</td></tr></tbody></table><h3 id="构建自己的centos">3 构建自己的CentOS</h3><p>下载CentOS基础镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull centos:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建dockerfile文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> mydockerfile-centos<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>写dockerfile文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#选择基础镜像。centos8 21年的时候停止了源服务，因此yum命令会报错。这里直接指定7版本</span>FROM centos:7<span class="token comment">#作者信息</span>MAINTAINER qjk<span class="token operator">&lt;</span><span class="token number">1256929691</span>@qq.com<span class="token operator">></span><span class="token comment">#环境变量</span>ENV MYPATH /usr/local<span class="token comment">#进入容器时的目录</span>WORKDIR <span class="token variable">$MYPATH</span><span class="token comment">#需要运行的命令</span>RUN yum -y <span class="token function">install</span> <span class="token function">vim</span>RUN yum -y <span class="token function">install</span> net-tools<span class="token comment">#暴露端口</span>EXPOSE <span class="token number">8888</span><span class="token comment">#输出一些信息</span>CMD <span class="token builtin class-name">echo</span> <span class="token variable">$MYPATH</span>CMD <span class="token builtin class-name">echo</span> <span class="token string">"---end---"</span><span class="token comment">#运行bash</span>CMD /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构建镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#-f 使用的dockerfile文件 -t 镜像名:版本号 . 当前上下文环境</span><span class="token function">docker</span> build -f mydockerfile-centos -t mycentos:1.0 <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it mycentos:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试发现安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@d92186b194dc local<span class="token punctuation">]</span><span class="token comment"># ifconfig </span>eth0: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">416</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu <span class="token number">1500</span>        inet <span class="token number">172.17</span>.0.2  netmask <span class="token number">255.255</span>.0.0  broadcast <span class="token number">172.17</span>.255.255        ether 02:42:ac:11:00:02  txqueuelen <span class="token number">0</span>  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets <span class="token number">8</span>  bytes <span class="token number">656</span> <span class="token punctuation">(</span><span class="token number">656.0</span> B<span class="token punctuation">)</span>        RX errors <span class="token number">0</span>  dropped <span class="token number">0</span>  overruns <span class="token number">0</span>  frame <span class="token number">0</span>        TX packets <span class="token number">0</span>  bytes <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span> B<span class="token punctuation">)</span>        TX errors <span class="token number">0</span>  dropped <span class="token number">0</span> overruns <span class="token number">0</span>  carrier <span class="token number">0</span>  collisions <span class="token number">0</span>lo: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">7</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,LOOPBACK,RUNNING<span class="token operator">></span>  mtu <span class="token number">65536</span>        inet <span class="token number">127.0</span>.0.1  netmask <span class="token number">255.0</span>.0.0        loop  txqueuelen <span class="token number">1000</span>  <span class="token punctuation">(</span>Local Loopback<span class="token punctuation">)</span>        RX packets <span class="token number">0</span>  bytes <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span> B<span class="token punctuation">)</span>        RX errors <span class="token number">0</span>  dropped <span class="token number">0</span>  overruns <span class="token number">0</span>  frame <span class="token number">0</span>        TX packets <span class="token number">0</span>  bytes <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span> B<span class="token punctuation">)</span>        TX errors <span class="token number">0</span>  dropped <span class="token number">0</span> overruns <span class="token number">0</span>  carrier <span class="token number">0</span>  collisions <span class="token number">0</span><span class="token punctuation">[</span>root@localhost data<span class="token punctuation">]</span><span class="token comment"># docker history mycentos:1.0</span>IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT68ec40605859   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  CMD ["/bin/sh" "-c" "/bin…   0B        </span>a611dbac6ce6   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  CMD ["/bin/sh" "-c" "echo…   0B        </span>3760049dc190   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  CMD ["/bin/sh" "-c" "echo…   0B        </span>8a9d3aecc1fb   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  EXPOSE 8888                  0B        </span>ba8c71fa6dde   <span class="token number">21</span> minutes ago   /bin/sh -c yum -y <span class="token function">install</span> net-tools             171MB     1de039243935   <span class="token number">21</span> minutes ago   /bin/sh -c yum -y <span class="token function">install</span> <span class="token function">vim</span>                   226MB     7f9dde17bf22   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop) WORKDIR /usr/local            0B        </span>97ada81ddf08   <span class="token number">21</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  ENV MYPATH=/usr/local        0B        </span>53e586d5ba0a   <span class="token number">22</span> minutes ago   /bin/sh -c <span class="token comment">#(nop)  MAINTAINER qjk&lt;1256929691…   0B        </span>eeb6ee3f44bd   <span class="token number">9</span> months ago     /bin/sh -c <span class="token comment">#(nop)  CMD ["/bin/bash"]            0B        </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">9</span> months ago     /bin/sh -c <span class="token comment">#(nop)  LABEL org.label-schema.sc…   0B        </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">9</span> months ago     /bin/sh -c <span class="token comment">#(nop) ADD file:b3ebbe8bd304723d4…   204MB     </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="cmd和entrypoint的区别">4 CMD和ENTRYPOINT的区别</h3><p>例如dockerfile中使用CMD命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">CMD <span class="token punctuation">[</span><span class="token string">"ls"</span>,<span class="token string">"-a"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>后续启动容器时想要执行<code>ls -l</code>命令，这样写会报错</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it mycentos:1.0 -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为<code>-l</code>会直接替换ls -a，正确的写法是这样</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it mycentos:1.0 <span class="token function">ls</span> -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如dockerfile中使用ENTRYPOINT命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"ls"</span>,<span class="token string">"-a"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样写就不会报错</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it mycentos:1.0 -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="构建tomcat">5 构建Tomcat</h3><p>Dockerfile文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FROM centos  COPY readme.md /usr/local/readme.md<span class="token comment">#添加压缩包，docker会自动解压</span>ADD jdk8.tar.gz /usr/localADD tomcat.tar.gz /usr/localRUN yum -y <span class="token function">install</span> <span class="token function">vim</span>ENV MYPATH /usr/localWORKDIR <span class="token variable">$MYPATH</span>ENV JAVA_HOME /usr/local/jdk1.8.0_141ENV CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jarENV <span class="token environment constant">PATH</span> <span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$JAVA_HOME</span>/binEXPOSE <span class="token number">8080</span><span class="token comment">#命令可以用&amp;&amp;直接拼接</span>CMD /usr/local/apache-tomcat-10.0.12/bin/startup.sh <span class="token operator">&amp;&amp;</span> <span class="token function">tail</span> -F /usr/local/apache-tomcat-10.0.12/bin/logs/catalina.out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="发布镜像">6 发布镜像</h3><blockquote><p>dockerhub</p></blockquote><ol type="1"><li>注册dockerhub账号</li><li>登录dockerhub</li><li>发布</li></ol><p>登录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> login -u 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过<code>tag</code>创建版本号</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> tag 镜像名<span class="token operator">|</span><span class="token function">id</span> 新的镜像名:版本号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发布</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> push 镜像名:版本号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="九-docker网络">九 Docker网络</h2><h3 id="docker0">1 Docker0</h3><p>通过命令<strong>ip addr</strong>查看本地ip地址，我们发现除了本机回环地址和埃里远的内网地址外，还多了一个网卡：Docker0，这是Docker服务启动后自动生成的。</p><p>而如果进入一个正在后台运行的tomcat容器，同样使用<strong>ip addr</strong>命令，发现容器得到了一个新的网络：<strong>12: eth@if13</strong>，ip地址：<strong>172.17.0.2</strong>。这是Docker在容器启动时为其分配的。</p><p>docker容器的网络是通过<code>veth</code>（Linux提供的虚拟网卡接口）来管理的。宿主机和容器分别连接到一个虚拟网卡接口。例如：宿主机一个新网络<strong>13: vethda1df4b@if12</strong>，对应容器内网络地址的<strong>12: eth@if13</strong>。12和13分别是宿主机端和容器端的接口编号。宿主机和容器之间可以ping通，容器与容器间也可以ping通，会通过docker0转发，docker0类似于局域网中的路由器。</p><figure><img src="http://img.meditate.eu.org/note/image-20220624095350600.png" alt="" /><figcaption>image-20220624095350600</figcaption></figure><p>容器一删除，对应的网桥也会随之删除。</p><h3 id="link">2 --link</h3><blockquote><p>若编写一个微服务并连接数据库，如果数据库ip改变，如何根据容器名而不是ip访问容器？显然，直接使用容器名是无法ping通容器内部的：</p></blockquote><p>这时我们可以在容器启动命令中加入一个选项：<strong>–link</strong>，使得我们可以根据容器名来访问容器。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d -P --link 容器名/id 镜像名/id<span class="token comment">#例如:启动一个容器并与tomcat01进行相连</span><span class="token function">docker</span> run -d -P --link tomcat01 --name tomcat02 tomcat:8 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>连接后，tomcat02可以直接ping tomcat01，而<strong>tomcat01却不能ping通tomcat02</strong>。</p><p>实现原理：在tomcat02的host文件中添加了tomcat01的ip地址。</p><p>显然这种方式过于低级，无法解决上述问题，因此--link不建议使用。</p><p>在实际开发中，docker0网卡的局限性过大，不支持服务名访问，因此往往会使用自己的网卡代替docker0。</p><h3 id="自定义网络">3 自定义网络</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看所有的docker网络</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker network ls</span>NETWORK ID     NAME      DRIVER    SCOPE8d9e97cd0f61   bridge    bridge    <span class="token builtin class-name">local</span>7d43eef7b13e   <span class="token function">host</span>      <span class="token function">host</span>      <span class="token builtin class-name">local</span>bc1e545c960e   none      null      <span class="token builtin class-name">local</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>docker中的网络模式有：</p><ul><li>bridge：桥接（docker默认）/</li><li>none：不配置网络 /</li><li>host：和宿主机共享网络</li></ul><p><code>docker run</code>命令默认带有一个参数–net bridge，此处的bridge指的就是docker0。可以自己手动创建一个新的网络。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span>  network create --driver 网络模式 --subnet 子网ip --gateway 网关 网络名     <span class="token comment">#例如</span><span class="token function">docker</span>  network create --driver bridge --subnet <span class="token number">192.168</span>.1.0/16 --gateway <span class="token number">192.168</span>.1.1 mynet     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>创建容器并使用自己创建的网络。这样创建的容器可以通过ping容器名直接ping通。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d --name tomcat01 -net mynet tomcat:8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="网络连通">4 网络连通</h3><p>对于建立在不同网络下(docker0, newnet)的两个容器tomcat01和tomcat02，他们的网段不同，因此是无法彼此ping通容器内部的：</p><p>这时我们需要通过docker network connect命令打通容器与网络之间的连接：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> network connect 网络名 容器名/id例如：<span class="token function">docker</span> network connect mynet tomcat01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十-springboot微服务打包成镜像">十 springboot微服务打包成镜像</h2><p>打包成jar包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mvn package<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编写Dockerfile</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FROM java:8COPY *.jar /app.jarCMD <span class="token punctuation">[</span><span class="token string">"--server.port=8080"</span><span class="token punctuation">]</span>EXPOSE <span class="token number">8080</span>ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"java"</span>,<span class="token string">"-jar"</span>,<span class="token string">"app.jar"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构建镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1.复制jar和DockerFIle到服务器</span><span class="token comment"># 2.构建镜像</span><span class="token function">docker</span> build -t xxxxx:xx  <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>壁纸</title>
      <link href="/2022/06/10/resource/bi-zhi/"/>
      <url>/2022/06/10/resource/bi-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="壁纸网站推荐">壁纸网站推荐</h1><h2 id="极简壁纸">极简壁纸</h2><p>https://bz.zzzmh.cn/index</p><p>一个中文的壁纸网站，壁纸质量很高，分类不太方便，适合桌面端。</p><h2 id="anime-pictures">anime-pictures</h2><p>https://anime-pictures.net/pictures/view_posts/0?lang=zh_CN</p><p>一个插画分享网站，全世界的画师可以在这个网站分享作品。主要以动漫人物为主。</p><h2 id="wallhaven">wallhaven</h2><p>https://wallhaven.cc/</p><p>最强大的壁纸网站，分类功能完善，壁纸种类弃齐全。</p><h2 id="wallpaperscraft">wallpaperscraft</h2><p>https://wallpaperscraft.com/</p><p>壁纸种类多，但是质量不怎么样。可以自定义壁纸的尺寸。</p><h2 id="wallpaperhub">wallpaperhub</h2><p>https://wallpaperhub.app/</p><p>主要是收集了一些产品的官方壁纸，比如Windows11，surface等。</p><h2 id="wallpaper-abyss">wallpaper abyss</h2><p>https://wall.alphacoders.com/</p><p>可以选择简体中文。搜索功能强大，输入关键词后可以很快找到想要的壁纸，壁纸也非常多。</p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 壁纸 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
